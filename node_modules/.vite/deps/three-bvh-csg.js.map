{
  "version": 3,
  "sources": ["../../three-mesh-bvh/src/core/Constants.js", "../../three-mesh-bvh/src/core/build/geometryUtils.js", "../../three-mesh-bvh/src/core/build/computeBoundsUtils.js", "../../three-mesh-bvh/src/utils/ArrayBoxUtilities.js", "../../three-mesh-bvh/src/core/build/splitUtils.js", "../../three-mesh-bvh/src/core/MeshBVHNode.js", "../../three-mesh-bvh/src/core/build/sortUtils.generated.js", "../../three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js", "../../three-mesh-bvh/src/core/utils/nodeBufferUtils.js", "../../three-mesh-bvh/src/core/build/buildUtils.js", "../../three-mesh-bvh/src/core/build/buildTree.js", "../../three-mesh-bvh/src/math/SeparatingAxisBounds.js", "../../three-mesh-bvh/src/math/MathUtilities.js", "../../three-mesh-bvh/src/math/ExtendedTriangle.js", "../../three-mesh-bvh/src/math/OrientedBox.js", "../../three-mesh-bvh/src/utils/PrimitivePool.js", "../../three-mesh-bvh/src/utils/ExtendedTrianglePool.js", "../../three-mesh-bvh/src/core/utils/BufferStack.js", "../../three-mesh-bvh/src/core/cast/shapecast.js", "../../three-mesh-bvh/src/core/cast/closestPointToPoint.js", "../../three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js", "../../three-mesh-bvh/src/utils/TriangleUtilities.js", "../../three-mesh-bvh/src/core/utils/iterationUtils.generated.js", "../../three-mesh-bvh/src/core/cast/refit.generated.js", "../../three-mesh-bvh/src/core/utils/intersectUtils.js", "../../three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/raycast.generated.js", "../../three-mesh-bvh/src/core/cast/raycastFirst.generated.js", "../../three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js", "../../three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js", "../../three-mesh-bvh/src/core/cast/refit_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/raycast_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js", "../../three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js", "../../three-mesh-bvh/src/utils/BufferUtils.js", "../../three-mesh-bvh/src/core/cast/bvhcast.js", "../../three-mesh-bvh/src/core/MeshBVH.js", "../../three-mesh-bvh/src/objects/MeshBVHHelper.js", "../../three-mesh-bvh/src/debug/Debug.js", "../../three-mesh-bvh/src/utils/ExtensionUtilities.js", "../../three-mesh-bvh/src/utils/StaticGeometryGenerator.js", "../../three-mesh-bvh/src/gpu/BVHShaderGLSL.js", "../../three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js", "../../three-mesh-bvh/src/gpu/glsl/bvh_distance_functions.glsl.js", "../../three-mesh-bvh/src/gpu/glsl/bvh_ray_functions.glsl.js", "../../three-mesh-bvh/src/gpu/glsl/bvh_struct_definitions.glsl.js", "../../three-mesh-bvh/src/index.js", "../../three-bvh-csg/src/core/utils/hashUtils.js", "../../three-bvh-csg/src/core/utils/geometryUtils.js", "../../three-bvh-csg/src/core/utils/halfEdgeUtils.js", "../../three-bvh-csg/src/core/utils/RaySet.js", "../../three-bvh-csg/src/core/utils/computeDisjointEdges.js", "../../three-bvh-csg/src/core/HalfEdgeMap.js", "../../three-bvh-csg/src/core/Brush.js", "../../three-bvh-csg/src/core/utils/triangleUtils.js", "../../three-bvh-csg/src/core/TriangleSplitter.js", "../../three-bvh-csg/src/core/TypeBackedArray.js", "../../three-bvh-csg/src/core/TypedAttributeData.js", "../../three-bvh-csg/src/core/IntersectionMap.js", "../../three-bvh-csg/src/core/constants.js", "../../three-bvh-csg/src/core/operations/operationsUtils.js", "../../three-bvh-csg/src/core/debug/OperationDebugData.js", "../../three-bvh-csg/src/core/operations/operations.js", "../../three-bvh-csg/src/core/Evaluator.js", "../../three-bvh-csg/src/core/operations/Operation.js", "../../three-bvh-csg/src/core/operations/OperationGroup.js", "../../three-bvh-csg/src/materials/shaderUtils.js", "../../three-bvh-csg/src/materials/GridMaterial.js", "../../three-bvh-csg/src/core/debug/debugUtils.js", "../../three-bvh-csg/src/objects/TriangleSetHelper.js", "../../three-bvh-csg/src/objects/EdgesHelper.js", "../../three-bvh-csg/src/objects/PointsHelper.js", "../../three-bvh-csg/src/objects/HalfEdgeHelper.js", "../../three-bvh-csg/src/utils/computeMeshVolume.js"],
  "sourcesContent": ["// Split strategy constants\r\nexport const CENTER = 0;\r\nexport const AVERAGE = 1;\r\nexport const SAH = 2;\r\n\r\n// Traversal constants\r\nexport const NOT_INTERSECTED = 0;\r\nexport const INTERSECTED = 1;\r\nexport const CONTAINED = 2;\r\n\r\n// SAH cost constants\r\n// TODO: hone these costs more. The relative difference between them should be the\r\n// difference in measured time to perform a triangle intersection vs traversing\r\n// bounds.\r\nexport const TRIANGLE_INTERSECT_COST = 1.25;\r\nexport const TRAVERSAL_COST = 1;\r\n\r\n\r\n// Build constants\r\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\r\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\r\n\r\n// EPSILON for computing floating point error during build\r\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\r\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\r\n\r\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\r\n", "import { BufferAttribute } from 'three';\r\n\r\nexport function getVertexCount( geo ) {\r\n\r\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\r\n\r\n}\r\n\r\nexport function getTriCount( geo ) {\r\n\r\n\treturn getVertexCount( geo ) / 3;\r\n\r\n}\r\n\r\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\r\n\r\n\tif ( vertexCount > 65535 ) {\r\n\r\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\r\n\r\n\t} else {\r\n\r\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// ensures that an index is present on the geometry\r\nexport function ensureIndex( geo, options ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n// region in the geometry index that belongs to a different set of material groups requires\r\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n// with triangle indices belongs to another group. For example, if the groups were like this:\r\n//\r\n// [-------------------------------------------------------------]\r\n// |__________________|\r\n//   g0 = [0, 20]  |______________________||_____________________|\r\n//                      g1 = [16, 40]           g2 = [41, 60]\r\n//\r\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\nexport function getFullGeometryRange( geo ) {\r\n\r\n\tconst triCount = getTriCount( geo );\r\n\tconst drawRange = geo.drawRange;\r\n\tconst start = drawRange.start / 3;\r\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\r\n\r\n\tconst offset = Math.max( 0, start );\r\n\tconst count = Math.min( triCount, end ) - offset;\r\n\treturn [ {\r\n\t\toffset: Math.floor( offset ),\r\n\t\tcount: Math.floor( count ),\r\n\t} ];\r\n\r\n}\r\n\r\nexport function getRootIndexRanges( geo ) {\r\n\r\n\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\treturn getFullGeometryRange( geo );\r\n\r\n\t}\r\n\r\n\tconst ranges = [];\r\n\tconst rangeBoundaries = new Set();\r\n\r\n\tconst drawRange = geo.drawRange;\r\n\tconst drawRangeStart = drawRange.start / 3;\r\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\r\n\tfor ( const group of geo.groups ) {\r\n\r\n\t\tconst groupStart = group.start / 3;\r\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\r\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\r\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\r\n\r\n\t}\r\n\r\n\r\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\tconst start = sortedBoundaries[ i ];\r\n\t\tconst end = sortedBoundaries[ i + 1 ];\r\n\r\n\t\tranges.push( {\r\n\t\t\toffset: Math.floor( start ),\r\n\t\t\tcount: Math.floor( end - start ),\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\treturn ranges;\r\n\r\n}\r\n\r\nexport function hasGroupGaps( geometry ) {\r\n\r\n\tif ( geometry.groups.length === 0 ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tconst vertexCount = getTriCount( geometry );\r\n\tconst groups = getRootIndexRanges( geometry )\r\n\t\t.sort( ( a, b ) => a.offset - b.offset );\r\n\r\n\tconst finalGroup = groups[ groups.length - 1 ];\r\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\r\n\r\n\tlet total = 0;\r\n\tgroups.forEach( ( { count } ) => total += count );\r\n\treturn vertexCount !== total;\r\n\r\n}\r\n", "import { FLOAT32_EPSILON } from '../Constants.js';\r\nimport { getTriCount } from './geometryUtils.js';\r\n\r\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\r\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\r\n// These are computed together to avoid redundant accesses to bounds array.\r\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\r\n\r\n\tlet minx = Infinity;\r\n\tlet miny = Infinity;\r\n\tlet minz = Infinity;\r\n\tlet maxx = - Infinity;\r\n\tlet maxy = - Infinity;\r\n\tlet maxz = - Infinity;\r\n\r\n\tlet cminx = Infinity;\r\n\tlet cminy = Infinity;\r\n\tlet cminz = Infinity;\r\n\tlet cmaxx = - Infinity;\r\n\tlet cmaxy = - Infinity;\r\n\tlet cmaxz = - Infinity;\r\n\r\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\r\n\r\n\t\tconst cx = triangleBounds[ i + 0 ];\r\n\t\tconst hx = triangleBounds[ i + 1 ];\r\n\t\tconst lx = cx - hx;\r\n\t\tconst rx = cx + hx;\r\n\t\tif ( lx < minx ) minx = lx;\r\n\t\tif ( rx > maxx ) maxx = rx;\r\n\t\tif ( cx < cminx ) cminx = cx;\r\n\t\tif ( cx > cmaxx ) cmaxx = cx;\r\n\r\n\t\tconst cy = triangleBounds[ i + 2 ];\r\n\t\tconst hy = triangleBounds[ i + 3 ];\r\n\t\tconst ly = cy - hy;\r\n\t\tconst ry = cy + hy;\r\n\t\tif ( ly < miny ) miny = ly;\r\n\t\tif ( ry > maxy ) maxy = ry;\r\n\t\tif ( cy < cminy ) cminy = cy;\r\n\t\tif ( cy > cmaxy ) cmaxy = cy;\r\n\r\n\t\tconst cz = triangleBounds[ i + 4 ];\r\n\t\tconst hz = triangleBounds[ i + 5 ];\r\n\t\tconst lz = cz - hz;\r\n\t\tconst rz = cz + hz;\r\n\t\tif ( lz < minz ) minz = lz;\r\n\t\tif ( rz > maxz ) maxz = rz;\r\n\t\tif ( cz < cminz ) cminz = cz;\r\n\t\tif ( cz > cmaxz ) cmaxz = cz;\r\n\r\n\t}\r\n\r\n\ttarget[ 0 ] = minx;\r\n\ttarget[ 1 ] = miny;\r\n\ttarget[ 2 ] = minz;\r\n\r\n\ttarget[ 3 ] = maxx;\r\n\ttarget[ 4 ] = maxy;\r\n\ttarget[ 5 ] = maxz;\r\n\r\n\tcentroidTarget[ 0 ] = cminx;\r\n\tcentroidTarget[ 1 ] = cminy;\r\n\tcentroidTarget[ 2 ] = cminz;\r\n\r\n\tcentroidTarget[ 3 ] = cmaxx;\r\n\tcentroidTarget[ 4 ] = cmaxy;\r\n\tcentroidTarget[ 5 ] = cmaxz;\r\n\r\n}\r\n\r\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\r\n// result is an array of size tris.length * 6 where triangle i maps to a\r\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\r\n// representing the center and half-extent in each dimension of triangle i\r\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\r\n\r\n\tconst posAttr = geo.attributes.position;\r\n\tconst index = geo.index ? geo.index.array : null;\r\n\tconst triCount = getTriCount( geo );\r\n\tconst normalized = posAttr.normalized;\r\n\tlet triangleBounds;\r\n\tif ( target === null ) {\r\n\r\n\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\r\n\t\toffset = 0;\r\n\t\tcount = triCount;\r\n\r\n\t} else {\r\n\r\n\t\ttriangleBounds = target;\r\n\t\toffset = offset || 0;\r\n\t\tcount = count || triCount;\r\n\r\n\t}\r\n\r\n\t// used for non-normalized positions\r\n\tconst posArr = posAttr.array;\r\n\r\n\t// support for an interleaved position buffer\r\n\tconst bufferOffset = posAttr.offset || 0;\r\n\tlet stride = 3;\r\n\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tstride = posAttr.data.stride;\r\n\r\n\t}\r\n\r\n\t// used for normalized positions\r\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\r\n\r\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\r\n\r\n\t\tconst tri3 = tri * 3;\r\n\t\tconst tri6 = tri * 6;\r\n\r\n\t\tlet ai = tri3 + 0;\r\n\t\tlet bi = tri3 + 1;\r\n\t\tlet ci = tri3 + 2;\r\n\r\n\t\tif ( index ) {\r\n\r\n\t\t\tai = index[ ai ];\r\n\t\t\tbi = index[ bi ];\r\n\t\t\tci = index[ ci ];\r\n\r\n\t\t}\r\n\r\n\t\t// we add the stride and offset here since we access the array directly\r\n\t\t// below for the sake of performance\r\n\t\tif ( ! normalized ) {\r\n\r\n\t\t\tai = ai * stride + bufferOffset;\r\n\t\t\tbi = bi * stride + bufferOffset;\r\n\t\t\tci = ci * stride + bufferOffset;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let el = 0; el < 3; el ++ ) {\r\n\r\n\t\t\tlet a, b, c;\r\n\r\n\t\t\tif ( normalized ) {\r\n\r\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\r\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\r\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ta = posArr[ ai + el ];\r\n\t\t\t\tb = posArr[ bi + el ];\r\n\t\t\t\tc = posArr[ ci + el ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet min = a;\r\n\t\t\tif ( b < min ) min = b;\r\n\t\t\tif ( c < min ) min = c;\r\n\r\n\t\t\tlet max = a;\r\n\t\t\tif ( b > max ) max = b;\r\n\t\t\tif ( c > max ) max = c;\r\n\r\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\r\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\r\n\t\t\t// worked with.\r\n\t\t\tconst halfExtents = ( max - min ) / 2;\r\n\t\t\tconst el2 = el * 2;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\r\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn triangleBounds;\r\n\r\n}\r\n", "export function arrayToBox( nodeIndex32, array, target ) {\r\n\r\n\ttarget.min.x = array[ nodeIndex32 ];\r\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\r\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\r\n\r\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\r\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\r\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\nexport function makeEmptyBounds( target ) {\r\n\r\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\r\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\r\n\r\n}\r\n\r\nexport function getLongestEdgeIndex( bounds ) {\r\n\r\n\tlet splitDimIdx = - 1;\r\n\tlet splitDist = - Infinity;\r\n\r\n\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\r\n\t\tif ( dist > splitDist ) {\r\n\r\n\t\t\tsplitDist = dist;\r\n\t\t\tsplitDimIdx = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn splitDimIdx;\r\n\r\n}\r\n\r\n// copies bounds a into bounds b\r\nexport function copyBounds( source, target ) {\r\n\r\n\ttarget.set( source );\r\n\r\n}\r\n\r\n// sets bounds target to the union of bounds a and b\r\nexport function unionBounds( a, b, target ) {\r\n\r\n\tlet aVal, bVal;\r\n\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\tconst d3 = d + 3;\r\n\r\n\t\t// set the minimum values\r\n\t\taVal = a[ d ];\r\n\t\tbVal = b[ d ];\r\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\r\n\r\n\t\t// set the max values\r\n\t\taVal = a[ d3 ];\r\n\t\tbVal = b[ d3 ];\r\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// expands the given bounds by the provided triangle bounds\r\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\r\n\r\n\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\r\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\r\n\r\n\t\tconst tMin = tCenter - tHalf;\r\n\t\tconst tMax = tCenter + tHalf;\r\n\r\n\t\tif ( tMin < bounds[ d ] ) {\r\n\r\n\t\t\tbounds[ d ] = tMin;\r\n\r\n\t\t}\r\n\r\n\t\tif ( tMax > bounds[ d + 3 ] ) {\r\n\r\n\t\t\tbounds[ d + 3 ] = tMax;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// compute bounds surface area\r\nexport function computeSurfaceArea( bounds ) {\r\n\r\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\r\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\r\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\r\n\r\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\r\n\r\n}\r\n", "import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\r\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\r\n\r\nconst BIN_COUNT = 32;\r\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\r\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\r\n\r\n\treturn {\r\n\r\n\t\tcount: 0,\r\n\t\tbounds: new Float32Array( 6 ),\r\n\t\trightCacheBounds: new Float32Array( 6 ),\r\n\t\tleftCacheBounds: new Float32Array( 6 ),\r\n\t\tcandidate: 0,\r\n\r\n\t};\r\n\r\n} );\r\nconst leftBounds = new Float32Array( 6 );\r\n\r\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\r\n\r\n\tlet axis = - 1;\r\n\tlet pos = 0;\r\n\r\n\t// Center\r\n\tif ( strategy === CENTER ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === AVERAGE ) {\r\n\r\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\r\n\t\tif ( axis !== - 1 ) {\r\n\r\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\r\n\r\n\t\t}\r\n\r\n\t} else if ( strategy === SAH ) {\r\n\r\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\r\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\r\n\r\n\t\t// iterate over all axes\r\n\t\tconst cStart = offset * 6;\r\n\t\tconst cEnd = ( offset + count ) * 6;\r\n\t\tfor ( let a = 0; a < 3; a ++ ) {\r\n\r\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\r\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\r\n\t\t\tconst axisLength = axisRight - axisLeft;\r\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\r\n\r\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\r\n\t\t\t// the triangle positions because it will be faster.\r\n\t\t\tif ( count < BIN_COUNT / 4 ) {\r\n\r\n\t\t\t\t// initialize the bin candidates\r\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\r\n\t\t\t\ttruncatedBins.length = count;\r\n\r\n\t\t\t\t// set the candidates\r\n\t\t\t\tlet b = 0;\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ b ];\r\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tbin.count = 0;\r\n\r\n\t\t\t\t\tconst {\r\n\t\t\t\t\t\tbounds,\r\n\t\t\t\t\t\tleftCacheBounds,\r\n\t\t\t\t\t\trightCacheBounds,\r\n\t\t\t\t\t} = bin;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\r\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttruncatedBins.sort( binsSort );\r\n\r\n\t\t\t\t// remove redundant splits\r\n\t\t\t\tlet splitCount = count;\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\r\n\r\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\r\n\t\t\t\t\t\tsplitCount --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\r\n\t\t\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// expand all the bounds\r\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\r\n\r\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\r\n\t\t\t\t\tconst leftCount = bin.count;\r\n\t\t\t\t\tconst rightCount = count - bin.count;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\r\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\r\n\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet rightProb = 0;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset the bins\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tbin.count = 0;\r\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\r\n\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\r\n\r\n\t\t\t\t\t\tbounds[ d ] = Infinity;\r\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterate over all center positions\r\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\r\n\r\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\r\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\r\n\r\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\r\n\t\t\t\t\t// considered to be on the right side of the split\r\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\r\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\r\n\r\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\r\n\t\t\t\t\tbin.count ++;\r\n\r\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\r\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\r\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\r\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet leftCount = 0;\r\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\r\n\r\n\t\t\t\t\tconst bin = sahBins[ i ];\r\n\t\t\t\t\tconst binCount = bin.count;\r\n\t\t\t\t\tconst bounds = bin.bounds;\r\n\r\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\r\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\r\n\r\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\r\n\t\t\t\t\tif ( binCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tif ( leftCount === 0 ) {\r\n\r\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tleftCount += binCount;\r\n\r\n\t\t\t\t\t// check the cost of this split\r\n\t\t\t\t\tlet leftProb = 0;\r\n\t\t\t\t\tlet rightProb = 0;\r\n\r\n\t\t\t\t\tif ( leftCount !== 0 ) {\r\n\r\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst rightCount = count - leftCount;\r\n\t\t\t\t\tif ( rightCount !== 0 ) {\r\n\r\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\r\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tif ( cost < bestCost ) {\r\n\r\n\t\t\t\t\t\taxis = a;\r\n\t\t\t\t\t\tbestCost = cost;\r\n\t\t\t\t\t\tpos = bin.candidate;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\r\n\r\n\t}\r\n\r\n\treturn { axis, pos };\r\n\r\n}\r\n\r\n// returns the average coordinate on the specified axis of the all the provided triangles\r\nfunction getAverage( triangleBounds, offset, count, axis ) {\r\n\r\n\tlet avg = 0;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\r\n\r\n\t}\r\n\r\n\treturn avg / count;\r\n\r\n}\r\n", "export class MeshBVHNode {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// internal nodes have boundingData, left, right, and splitAxis\r\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\r\n\r\n\t\tthis.boundingData = new Float32Array( 6 );\r\n\r\n\t}\r\n\r\n}\r\n", "/********************************************************/\r\n/* This file is generated from \"sortUtils.template.js\". */\r\n/********************************************************/\r\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n// of the first element on the right side, or offset + count if there are no elements on the right side.\r\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\r\n\r\n\tlet left = offset;\r\n\tlet right = offset + count - 1;\r\n\tconst pos = split.pos;\r\n\tconst axisOffset = split.axis * 2;\r\n\r\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\twhile ( true ) {\r\n\r\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\tleft ++;\r\n\r\n\t\t}\r\n\r\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\r\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\tright --;\r\n\r\n\t\t}\r\n\r\n\t\tif ( left < right ) {\r\n\r\n\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t// and perhaps the SAH planes\r\n\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tlet t0 = index[ left * 3 + i ];\r\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\r\n\t\t\t\tindex[ right * 3 + i ] = t0;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\t// swap bounds\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tleft ++;\r\n\t\t\tright --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn left;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { partition };\r\n", "/********************************************************/\r\n/* This file is generated from \"sortUtils.template.js\". */\r\n/********************************************************/\r\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\r\n// will be on the left and elements on the right side of the split will be on the right. returns the index\r\n// of the first element on the right side, or offset + count if there are no elements on the right side.\r\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\r\n\r\n\tlet left = offset;\r\n\tlet right = offset + count - 1;\r\n\tconst pos = split.pos;\r\n\tconst axisOffset = split.axis * 2;\r\n\r\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\r\n\twhile ( true ) {\r\n\r\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\r\n\r\n\t\t\tleft ++;\r\n\r\n\t\t}\r\n\r\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\r\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\r\n\r\n\t\t\tright --;\r\n\r\n\t\t}\r\n\r\n\t\tif ( left < right ) {\r\n\r\n\t\t\t// we need to swap all of the information associated with the triangles at index\r\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\r\n\t\t\t// and perhaps the SAH planes\r\n\t\t\tlet t = indirectBuffer[ left ];\r\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\r\n\t\t\tindirectBuffer[ right ] = t;\r\n\r\n\r\n\t\t\t// swap bounds\r\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\r\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\r\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tleft ++;\r\n\t\t\tright --;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn left;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { partition_indirect };\r\n", "export function IS_LEAF( n16, uint16Array ) {\r\n\r\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\r\n\r\n}\r\n\r\nexport function OFFSET( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 6 ];\r\n\r\n}\r\n\r\nexport function COUNT( n16, uint16Array ) {\r\n\r\n\treturn uint16Array[ n16 + 14 ];\r\n\r\n}\r\n\r\nexport function LEFT_NODE( n32 ) {\r\n\r\n\treturn n32 + 8;\r\n\r\n}\r\n\r\nexport function RIGHT_NODE( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 6 ];\r\n\r\n}\r\n\r\nexport function SPLIT_AXIS( n32, uint32Array ) {\r\n\r\n\treturn uint32Array[ n32 + 7 ];\r\n\r\n}\r\n\r\nexport function BOUNDING_DATA_INDEX( n32 ) {\r\n\r\n\treturn n32;\r\n\r\n}\r\n", "import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\r\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\r\n\r\nlet float32Array, uint32Array, uint16Array, uint8Array;\r\nconst MAX_POINTER = Math.pow( 2, 32 );\r\n\r\nexport function countNodes( node ) {\r\n\r\n\tif ( 'count' in node ) {\r\n\r\n\t\treturn 1;\r\n\r\n\t} else {\r\n\r\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function populateBuffer( byteOffset, node, buffer ) {\r\n\r\n\tfloat32Array = new Float32Array( buffer );\r\n\tuint32Array = new Uint32Array( buffer );\r\n\tuint16Array = new Uint16Array( buffer );\r\n\tuint8Array = new Uint8Array( buffer );\r\n\r\n\treturn _populateBuffer( byteOffset, node );\r\n\r\n}\r\n\r\n// pack structure\r\n// boundingData  \t\t\t\t: 6 float32\r\n// right / offset \t\t\t\t: 1 uint32\r\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\r\nfunction _populateBuffer( byteOffset, node ) {\r\n\r\n\tconst stride4Offset = byteOffset / 4;\r\n\tconst stride2Offset = byteOffset / 2;\r\n\tconst isLeaf = 'count' in node;\r\n\tconst boundingData = node.boundingData;\r\n\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\r\n\r\n\t}\r\n\r\n\tif ( isLeaf ) {\r\n\r\n\t\tif ( node.buffer ) {\r\n\r\n\t\t\tconst buffer = node.buffer;\r\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\r\n\r\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\r\n\r\n\t\t\t\tconst offset2 = offset / 2;\r\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\r\n\r\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn byteOffset + buffer.byteLength;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst offset = node.offset;\r\n\t\t\tconst count = node.count;\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\r\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\r\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\r\n\t\t\treturn byteOffset + BYTES_PER_NODE;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst left = node.left;\r\n\t\tconst right = node.right;\r\n\t\tconst splitAxis = node.splitAxis;\r\n\r\n\t\tlet nextUnusedPointer;\r\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\r\n\r\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\r\n\r\n\t\t}\r\n\r\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\r\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\r\n\r\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\r\n\t\treturn nextUnusedPointer;\r\n\r\n\t}\r\n\r\n}\r\n", "import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\r\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\r\nimport { getOptimalSplit } from './splitUtils.js';\r\nimport { MeshBVHNode } from '../MeshBVHNode.js';\r\nimport { BYTES_PER_NODE } from '../Constants.js';\r\n\r\nimport { partition } from './sortUtils.generated.js';\r\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\r\nimport { countNodes, populateBuffer } from './buildUtils.js';\r\n\r\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\r\n\r\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\tconst useUint32 = triCount > 2 ** 16;\r\n\tconst byteCount = useUint32 ? 4 : 2;\r\n\r\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\r\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\r\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\r\n\r\n\t\tindirectBuffer[ i ] = i;\r\n\r\n\t}\r\n\r\n\treturn indirectBuffer;\r\n\r\n}\r\n\r\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\r\n\r\n\t// epxand variables\r\n\tconst {\r\n\t\tmaxDepth,\r\n\t\tverbose,\r\n\t\tmaxLeafTris,\r\n\t\tstrategy,\r\n\t\tonProgress,\r\n\t\tindirect,\r\n\t} = options;\r\n\tconst indirectBuffer = bvh._indirectBuffer;\r\n\tconst geometry = bvh.geometry;\r\n\tconst indexArray = geometry.index ? geometry.index.array : null;\r\n\tconst partionFunc = indirect ? partition_indirect : partition;\r\n\r\n\t// generate intermediate variables\r\n\tconst totalTriangles = getTriCount( geometry );\r\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\r\n\tlet reachedMaxDepth = false;\r\n\r\n\tconst root = new MeshBVHNode();\r\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\r\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\r\n\treturn root;\r\n\r\n\tfunction triggerProgress( trianglesProcessed ) {\r\n\r\n\t\tif ( onProgress ) {\r\n\r\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\r\n\r\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\r\n\r\n\t\t\treachedMaxDepth = true;\r\n\t\t\tif ( verbose ) {\r\n\r\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\t\tconsole.warn( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// early out if we've met our capacity\r\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// Find where to split the volume\r\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\r\n\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\r\n\r\n\t\t// create the two new child nodes\r\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t// create the left child and compute its bounding box\r\n\t\t\tconst left = new MeshBVHNode();\r\n\t\t\tconst lstart = offset;\r\n\t\t\tconst lcount = splitOffset - offset;\r\n\t\t\tnode.left = left;\r\n\r\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t\t// repeat for right\r\n\t\t\tconst right = new MeshBVHNode();\r\n\t\t\tconst rstart = splitOffset;\r\n\t\t\tconst rcount = count - lcount;\r\n\t\t\tnode.right = right;\r\n\r\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function buildPackedTree( bvh, options ) {\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tif ( options.indirect ) {\r\n\r\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\r\n\r\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\r\n\r\n\t\t\tconsole.warn(\r\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\r\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( ! bvh._indirectBuffer ) {\r\n\r\n\t\tensureIndex( geometry, options );\r\n\r\n\t}\r\n\r\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\r\n\tconst triangleBounds = computeTriangleBounds( geometry );\r\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\r\n\tbvh._roots = geometryRanges.map( range => {\r\n\r\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\r\n\t\tconst nodeCount = countNodes( root );\r\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\r\n\t\tpopulateBuffer( 0, root, buffer );\r\n\t\treturn buffer;\r\n\r\n\t} );\r\n\r\n}\r\n", "import { Vector3 } from 'three';\r\n\r\nexport class SeparatingAxisBounds {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.min = Infinity;\r\n\t\tthis.max = - Infinity;\r\n\r\n\t}\r\n\r\n\tsetFromPointsField( points, field ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = p[ field ];\r\n\t\t\tmin = val < min ? val : min;\r\n\t\t\tmax = val > max ? val : max;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tsetFromPoints( axis, points ) {\r\n\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tconst val = axis.dot( p );\r\n\t\t\tmin = val < min ? val : min;\r\n\t\t\tmax = val > max ? val : max;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t}\r\n\r\n\tisSeparated( other ) {\r\n\r\n\t\treturn this.min > other.max || other.min > this.max;\r\n\r\n\t}\r\n\r\n}\r\n\r\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\r\n\r\n\tconst p = new Vector3();\r\n\treturn function setFromBox( axis, box ) {\r\n\r\n\t\tconst boxMin = box.min;\r\n\t\tconst boxMax = box.max;\r\n\t\tlet min = Infinity;\r\n\t\tlet max = - Infinity;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\r\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\r\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\r\n\r\n\t\t\t\t\tconst val = axis.dot( p );\r\n\t\t\t\t\tmin = Math.min( val, min );\r\n\t\t\t\t\tmax = Math.max( val, max );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.min = min;\r\n\t\tthis.max = max;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const areIntersecting = ( function () {\r\n\r\n\tconst cacheSatBounds = new SeparatingAxisBounds();\r\n\treturn function areIntersecting( shape1, shape2 ) {\r\n\r\n\t\tconst points1 = shape1.points;\r\n\t\tconst satAxes1 = shape1.satAxes;\r\n\t\tconst satBounds1 = shape1.satBounds;\r\n\r\n\t\tconst points2 = shape2.points;\r\n\t\tconst satAxes2 = shape2.satAxes;\r\n\t\tconst satBounds2 = shape2.satBounds;\r\n\r\n\t\t// check axes of the first shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check axes of the second shape\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\r\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n", "import { Vector3, Vector2, Plane, Line3 } from 'three';\r\n\r\nexport const closestPointLineToLine = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst v02 = new Vector3();\r\n\treturn function closestPointLineToLine( l1, l2, result ) {\r\n\r\n\t\tconst v0 = l1.start;\r\n\t\tconst v10 = dir1;\r\n\t\tconst v2 = l2.start;\r\n\t\tconst v32 = dir2;\r\n\r\n\t\tv02.subVectors( v0, v2 );\r\n\t\tdir1.subVectors( l1.end, l1.start );\r\n\t\tdir2.subVectors( l2.end, l2.start );\r\n\r\n\t\t// float d0232 = v02.Dot(v32);\r\n\t\tconst d0232 = v02.dot( v32 );\r\n\r\n\t\t// float d3210 = v32.Dot(v10);\r\n\t\tconst d3210 = v32.dot( v10 );\r\n\r\n\t\t// float d3232 = v32.Dot(v32);\r\n\t\tconst d3232 = v32.dot( v32 );\r\n\r\n\t\t// float d0210 = v02.Dot(v10);\r\n\t\tconst d0210 = v02.dot( v10 );\r\n\r\n\t\t// float d1010 = v10.Dot(v10);\r\n\t\tconst d1010 = v10.dot( v10 );\r\n\r\n\t\t// float denom = d1010*d3232 - d3210*d3210;\r\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\r\n\r\n\t\tlet d, d2;\r\n\t\tif ( denom !== 0 ) {\r\n\r\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\r\n\r\n\t\t} else {\r\n\r\n\t\t\td = 0;\r\n\r\n\t\t}\r\n\r\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\r\n\r\n\t\tresult.x = d;\r\n\t\tresult.y = d2;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nexport const closestPointsSegmentToSegment = ( function () {\r\n\r\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\r\n\tconst paramResult = new Vector2();\r\n\tconst temp1 = new Vector3();\r\n\tconst temp2 = new Vector3();\r\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\r\n\r\n\t\tclosestPointLineToLine( l1, l2, paramResult );\r\n\r\n\t\tlet d = paramResult.x;\r\n\t\tlet d2 = paramResult.y;\r\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\tl1.at( d, target1 );\r\n\t\t\tl2.at( d2, target2 );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d >= 0 && d <= 1 ) {\r\n\r\n\t\t\t// Only d2 is out of bounds.\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tl2.at( 0, target2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl2.at( 1, target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\r\n\t\t\treturn;\r\n\r\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\r\n\r\n\t\t\t// Only d is out of bounds.\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tl1.at( 0, target1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tl1.at( 1, target1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Both u and u2 are out of bounds.\r\n\t\t\tlet p;\r\n\t\t\tif ( d < 0 ) {\r\n\r\n\t\t\t\tp = l1.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp = l1.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet p2;\r\n\t\t\tif ( d2 < 0 ) {\r\n\r\n\t\t\t\tp2 = l2.start;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp2 = l2.end;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst closestPoint = temp1;\r\n\t\t\tconst closestPoint2 = temp2;\r\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\r\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\r\n\r\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\r\n\r\n\t\t\t\ttarget1.copy( closestPoint );\r\n\t\t\t\ttarget2.copy( p2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\ttarget1.copy( p );\r\n\t\t\t\ttarget2.copy( closestPoint2 );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nexport const sphereIntersectTriangle = ( function () {\r\n\r\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\r\n\tconst closestPointTemp = new Vector3();\r\n\tconst projectedPointTemp = new Vector3();\r\n\tconst planeTemp = new Plane();\r\n\tconst lineTemp = new Line3();\r\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\r\n\r\n\t\tconst { radius, center } = sphere;\r\n\t\tconst { a, b, c } = triangle;\r\n\r\n\t\t// phase 1\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = b;\r\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = a;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\tlineTemp.start = b;\r\n\t\tlineTemp.end = c;\r\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\r\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\r\n\r\n\t\t// phase 2\r\n\t\tconst plane = triangle.getPlane( planeTemp );\r\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\r\n\t\tif ( dp <= radius ) {\r\n\r\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\r\n\t\t\tconst cp = triangle.containsPoint( pp );\r\n\t\t\tif ( cp ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t};\r\n\r\n} )();\r\n", "import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\r\n\r\nconst ZERO_EPSILON = 1e-15;\r\nfunction isNearZero( value ) {\r\n\r\n\treturn Math.abs( value ) < ZERO_EPSILON;\r\n\r\n}\r\n\r\nexport class ExtendedTriangle extends Triangle {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isExtendedTriangle = true;\r\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.points = [ this.a, this.b, this.c ];\r\n\t\tthis.sphere = new Sphere();\r\n\t\tthis.plane = new Plane();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn sphereIntersectTriangle( sphere, this );\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst a = this.a;\r\n\t\tconst b = this.b;\r\n\t\tconst c = this.c;\r\n\t\tconst points = this.points;\r\n\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst satBounds = this.satBounds;\r\n\r\n\t\tconst axis0 = satAxes[ 0 ];\r\n\t\tconst sab0 = satBounds[ 0 ];\r\n\t\tthis.getNormal( axis0 );\r\n\t\tsab0.setFromPoints( axis0, points );\r\n\r\n\t\tconst axis1 = satAxes[ 1 ];\r\n\t\tconst sab1 = satBounds[ 1 ];\r\n\t\taxis1.subVectors( a, b );\r\n\t\tsab1.setFromPoints( axis1, points );\r\n\r\n\t\tconst axis2 = satAxes[ 2 ];\r\n\t\tconst sab2 = satBounds[ 2 ];\r\n\t\taxis2.subVectors( b, c );\r\n\t\tsab2.setFromPoints( axis2, points );\r\n\r\n\t\tconst axis3 = satAxes[ 3 ];\r\n\t\tconst sab3 = satBounds[ 3 ];\r\n\t\taxis3.subVectors( c, a );\r\n\t\tsab3.setFromPoints( axis3, points );\r\n\r\n\t\tthis.sphere.setFromPoints( this.points );\r\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t}\r\n\r\n}\r\n\r\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst edge = new Line3();\r\n\r\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\r\n\r\n\t\tconst { start, end } = segment;\r\n\t\tconst points = this.points;\r\n\t\tlet distSq;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check the triangle edges\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst nexti = ( i + 1 ) % 3;\r\n\t\t\tedge.start.copy( points[ i ] );\r\n\t\t\tedge.end.copy( points[ nexti ] );\r\n\r\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\r\n\r\n\t\t\tdistSq = point1.distanceToSquared( point2 );\r\n\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check end points\r\n\t\tthis.closestPointToPoint( start, point1 );\r\n\t\tdistSq = start.distanceToSquared( point1 );\r\n\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\tclosestDistanceSq = distSq;\r\n\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\tif ( target2 ) target2.copy( start );\r\n\r\n\t\t}\r\n\r\n\t\tthis.closestPointToPoint( end, point1 );\r\n\t\tdistSq = end.distanceToSquared( point1 );\r\n\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\tclosestDistanceSq = distSq;\r\n\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\tif ( target2 ) target2.copy( end );\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri2 = new ExtendedTriangle();\r\n\tconst arr1 = new Array( 3 );\r\n\tconst arr2 = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\tconst dir = new Vector3();\r\n\tconst dir1 = new Vector3();\r\n\tconst dir2 = new Vector3();\r\n\tconst tempDir = new Vector3();\r\n\tconst edge = new Line3();\r\n\tconst edge1 = new Line3();\r\n\tconst edge2 = new Line3();\r\n\tconst tempPoint = new Vector3();\r\n\r\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\r\n\r\n\t\t// find the edge that intersects the other triangle plane\r\n\t\tconst points = tri.points;\r\n\t\tlet count = 0;\r\n\t\tlet startPointIntersection = - 1;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst { start, end } = edge;\r\n\t\t\tstart.copy( points[ i ] );\r\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\r\n\t\t\tedge.delta( dir );\r\n\r\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\r\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\r\n\r\n\t\t\t\t// if the edge lies on the plane then take the line\r\n\t\t\t\ttargetEdge.copy( edge );\r\n\t\t\t\tcount = 2;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\r\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\r\n\t\t\tif ( ! doesIntersect && startIntersects ) {\r\n\r\n\t\t\t\ttempPoint.copy( start );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// ignore the end point\r\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\r\n\r\n\t\t\t\tif ( count <= 1 ) {\r\n\r\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\r\n\t\t\t\t\t// the start point if necessary\r\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\r\n\t\t\t\t\tpoint.copy( tempPoint );\r\n\t\t\t\t\tif ( startIntersects ) {\r\n\r\n\t\t\t\t\t\tstartPointIntersection = count;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( count >= 2 ) {\r\n\r\n\t\t\t\t\t// if we're here that means that there must have been one point that had\r\n\t\t\t\t\t// snapped to the start point so replace it here\r\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\r\n\t\t\t\t\tpoint.copy( tempPoint );\r\n\t\t\t\t\tcount = 2;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcount ++;\r\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\r\n\t}\r\n\r\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\r\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\r\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! other.isExtendedTriangle ) {\r\n\r\n\t\t\tsaTri2.copy( other );\r\n\t\t\tsaTri2.update();\r\n\t\t\tother = saTri2;\r\n\r\n\t\t} else if ( other.needsUpdate ) {\r\n\r\n\t\t\tother.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst plane1 = this.plane;\r\n\t\tconst plane2 = other.plane;\r\n\r\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\r\n\r\n\t\t\t// perform separating axis intersection test only for coplanar triangles\r\n\t\t\tconst satBounds1 = this.satBounds;\r\n\t\t\tconst satAxes1 = this.satAxes;\r\n\t\t\tarr2[ 0 ] = other.a;\r\n\t\t\tarr2[ 1 ] = other.b;\r\n\t\t\tarr2[ 2 ] = other.c;\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sb = satBounds1[ i ];\r\n\t\t\t\tconst sa = satAxes1[ i ];\r\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\r\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst satBounds2 = other.satBounds;\r\n\t\t\tconst satAxes2 = other.satAxes;\r\n\t\t\tarr1[ 0 ] = this.a;\r\n\t\t\tarr1[ 1 ] = this.b;\r\n\t\t\tarr1[ 2 ] = this.c;\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sb = satBounds2[ i ];\r\n\t\t\t\tconst sa = satAxes2[ i ];\r\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\r\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check crossed axes\r\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\tconst sa1 = satAxes1[ i ];\r\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\r\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\r\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\r\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\r\n\t\t\t\tif ( ! suppressLog ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttarget.start.set( 0, 0, 0 );\r\n\t\t\t\ttarget.end.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// find the edge that intersects the other triangle plane\r\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\r\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\r\n\r\n\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge1.end );\r\n\t\t\t\t\ttarget.end.copy( edge1.end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else if ( count1 !== 2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find the other triangles edge that intersects this plane\r\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\r\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\r\n\r\n\t\t\t\tif ( target ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge2.end );\r\n\t\t\t\t\ttarget.end.copy( edge2.end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else if ( count2 !== 2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// find swap the second edge so both lines are running the same direction\r\n\t\t\tedge1.delta( dir1 );\r\n\t\t\tedge2.delta( dir2 );\r\n\r\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\r\n\r\n\t\t\t\tlet tmp = edge2.start;\r\n\t\t\t\tedge2.start = edge2.end;\r\n\t\t\t\tedge2.end = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if the edges are overlapping\r\n\t\t\tconst s1 = edge1.start.dot( dir1 );\r\n\t\t\tconst e1 = edge1.end.dot( dir1 );\r\n\t\t\tconst s2 = edge2.start.dot( dir1 );\r\n\t\t\tconst e2 = edge2.end.dot( dir1 );\r\n\t\t\tconst separated1 = e1 < s2;\r\n\t\t\tconst separated2 = s1 < e2;\r\n\r\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// assign the target output\r\n\t\t\tif ( target ) {\r\n\r\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\r\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge1.start );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttarget.start.copy( edge2.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\r\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\r\n\r\n\t\t\t\t\ttarget.end.copy( edge1.end );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttarget.end.copy( edge2.end );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nExtendedTriangle.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n\r\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\r\n\r\n\tconst point = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\tconst cornerFields = [ 'a', 'b', 'c' ];\r\n\tconst line1 = new Line3();\r\n\tconst line2 = new Line3();\r\n\r\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\r\n\r\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\r\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\r\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check all point distances\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tlet dist;\r\n\t\t\tconst field = cornerFields[ i ];\r\n\t\t\tconst otherVec = other[ field ];\r\n\t\t\tthis.closestPointToPoint( otherVec, point );\r\n\r\n\t\t\tdist = otherVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tconst thisVec = this[ field ];\r\n\t\t\tother.closestPointToPoint( thisVec, point );\r\n\r\n\t\t\tdist = thisVec.distanceToSquared( point );\r\n\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\r\n\t\t\t\tif ( target2 ) target2.copy( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst f11 = cornerFields[ i ];\r\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\r\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\r\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\r\n\r\n\t\t\t\tconst f21 = cornerFields[ i2 ];\r\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\r\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\r\n\r\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\r\n\r\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n", "import { Vector3, Matrix4, Line3 } from 'three';\r\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\r\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\r\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\r\n\r\nexport class OrientedBox {\r\n\r\n\tconstructor( min, max, matrix ) {\r\n\r\n\t\tthis.isOrientedBox = true;\r\n\t\tthis.min = new Vector3();\r\n\t\tthis.max = new Vector3();\r\n\t\tthis.matrix = new Matrix4();\r\n\t\tthis.invMatrix = new Matrix4();\r\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\r\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\r\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t\tif ( min ) this.min.copy( min );\r\n\t\tif ( max ) this.max.copy( max );\r\n\t\tif ( matrix ) this.matrix.copy( matrix );\r\n\r\n\t}\r\n\r\n\tset( min, max, matrix ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\t\tthis.matrix.copy( matrix );\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tthis.min.copy( other.min );\r\n\t\tthis.max.copy( other.max );\r\n\t\tthis.matrix.copy( other.matrix );\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\nOrientedBox.prototype.update = ( function () {\r\n\r\n\treturn function update() {\r\n\r\n\t\tconst matrix = this.matrix;\r\n\t\tconst min = this.min;\r\n\t\tconst max = this.max;\r\n\r\n\t\tconst points = this.points;\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\r\n\t\t\t\t\tconst v = points[ i ];\r\n\t\t\t\t\tv.x = x ? max.x : min.x;\r\n\t\t\t\t\tv.y = y ? max.y : min.y;\r\n\t\t\t\t\tv.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tv.applyMatrix4( matrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst minVec = points[ 0 ];\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst index = 1 << i;\r\n\t\t\tconst pi = points[ index ];\r\n\r\n\t\t\taxis.subVectors( minVec, pi );\r\n\t\t\tsb.setFromPoints( axis, points );\r\n\r\n\t\t}\r\n\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\r\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\r\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\r\n\r\n\t\tthis.invMatrix.copy( this.matrix ).invert();\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsBox = ( function () {\r\n\r\n\tconst aabbBounds = new SeparatingAxisBounds();\r\n\treturn function intersectsBox( box ) {\r\n\r\n\t\t// TODO: should this be doing SAT against the AABB?\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\t\tconst alignedSatBounds = this.alignedSatBounds;\r\n\r\n\t\taabbBounds.min = min.x;\r\n\t\taabbBounds.max = max.x;\r\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.y;\r\n\t\taabbBounds.max = max.y;\r\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\taabbBounds.min = min.z;\r\n\t\taabbBounds.max = max.z;\r\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst axis = satAxes[ i ];\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\taabbBounds.setFromBox( axis, box );\r\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.intersectsTriangle = ( function () {\r\n\r\n\tconst saTri = new ExtendedTriangle();\r\n\tconst pointsArr = new Array( 3 );\r\n\tconst cachedSatBounds = new SeparatingAxisBounds();\r\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\r\n\tconst cachedAxis = new Vector3();\r\n\treturn function intersectsTriangle( triangle ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! triangle.isExtendedTriangle ) {\r\n\r\n\t\t\tsaTri.copy( triangle );\r\n\t\t\tsaTri.update();\r\n\t\t\ttriangle = saTri;\r\n\r\n\t\t} else if ( triangle.needsUpdate ) {\r\n\r\n\t\t\ttriangle.update();\r\n\r\n\t\t}\r\n\r\n\t\tconst satBounds = this.satBounds;\r\n\t\tconst satAxes = this.satAxes;\r\n\r\n\t\tpointsArr[ 0 ] = triangle.a;\r\n\t\tpointsArr[ 1 ] = triangle.b;\r\n\t\tpointsArr[ 2 ] = triangle.c;\r\n\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = satBounds[ i ];\r\n\t\t\tconst sa = satAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\tconst triSatBounds = triangle.satBounds;\r\n\t\tconst triSatAxes = triangle.satAxes;\r\n\t\tconst points = this.points;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sb = triSatBounds[ i ];\r\n\t\t\tconst sa = triSatAxes[ i ];\r\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\r\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\r\n\r\n\t\t}\r\n\r\n\t\t// check crossed axes\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tconst sa1 = satAxes[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\r\n\r\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\r\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\r\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\r\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\r\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.closestPointToPoint = ( function () {\r\n\r\n\treturn function closestPointToPoint( point, target1 ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\ttarget1\r\n\t\t\t.copy( point )\r\n\t\t\t.applyMatrix4( this.invMatrix )\r\n\t\t\t.clamp( this.min, this.max )\r\n\t\t\t.applyMatrix4( this.matrix );\r\n\r\n\t\treturn target1;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToPoint = ( function () {\r\n\r\n\tconst target = new Vector3();\r\n\treturn function distanceToPoint( point ) {\r\n\r\n\t\tthis.closestPointToPoint( point, target );\r\n\t\treturn point.distanceTo( target );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nOrientedBox.prototype.distanceToBox = ( function () {\r\n\r\n\tconst xyzFields = [ 'x', 'y', 'z' ];\r\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\r\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\r\n\r\n\tconst point1 = new Vector3();\r\n\tconst point2 = new Vector3();\r\n\r\n\t// early out if we find a value below threshold\r\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\r\n\r\n\t\tif ( this.needsUpdate ) {\r\n\r\n\t\t\tthis.update();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.intersectsBox( box ) ) {\r\n\r\n\t\t\tif ( target1 || target2 ) {\r\n\r\n\t\t\t\tbox.getCenter( point2 );\r\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\r\n\r\n\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst threshold2 = threshold * threshold;\r\n\t\tconst min = box.min;\r\n\t\tconst max = box.max;\r\n\t\tconst points = this.points;\r\n\r\n\r\n\t\t// iterate over every edge and compare distances\r\n\t\tlet closestDistanceSq = Infinity;\r\n\r\n\t\t// check over all these points\r\n\t\tfor ( let i = 0; i < 8; i ++ ) {\r\n\r\n\t\t\tconst p = points[ i ];\r\n\t\t\tpoint2.copy( p ).clamp( min, max );\r\n\r\n\t\t\tconst dist = p.distanceToSquared( point2 );\r\n\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\tif ( target1 ) target1.copy( p );\r\n\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate and check all line segment distances\r\n\t\tlet count = 0;\r\n\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\r\n\r\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\r\n\r\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\r\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\r\n\r\n\t\t\t\t\t// get obb line segments\r\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\r\n\t\t\t\t\tconst p1 = points[ index ];\r\n\t\t\t\t\tconst p2 = points[ index2 ];\r\n\t\t\t\t\tconst line1 = segments1[ count ];\r\n\t\t\t\t\tline1.set( p1, p2 );\r\n\r\n\r\n\t\t\t\t\t// get aabb line segments\r\n\t\t\t\t\tconst f1 = xyzFields[ i ];\r\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\r\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\r\n\t\t\t\t\tconst line2 = segments2[ count ];\r\n\t\t\t\t\tconst start = line2.start;\r\n\t\t\t\t\tconst end = line2.end;\r\n\r\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\r\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\r\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\r\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\r\n\r\n\t\t\t\t\tcount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// check all the other boxes point\r\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\r\n\r\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\r\n\r\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\r\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\r\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\r\n\r\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\r\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\r\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < 12; i ++ ) {\r\n\r\n\t\t\tconst l1 = segments1[ i ];\r\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\r\n\r\n\t\t\t\tconst l2 = segments2[ i2 ];\r\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\r\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\r\n\t\t\t\tif ( dist < closestDistanceSq ) {\r\n\r\n\t\t\t\t\tclosestDistanceSq = dist;\r\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\r\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\r\n\r\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Math.sqrt( closestDistanceSq );\r\n\r\n\t};\r\n\r\n} )();\r\n", "export class PrimitivePool {\r\n\r\n\tconstructor( getNewPrimitive ) {\r\n\r\n\t\tthis._getNewPrimitive = getNewPrimitive;\r\n\t\tthis._primitives = [];\r\n\r\n\t}\r\n\r\n\tgetPrimitive() {\r\n\r\n\t\tconst primitives = this._primitives;\r\n\t\tif ( primitives.length === 0 ) {\r\n\r\n\t\t\treturn this._getNewPrimitive();\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn primitives.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treleasePrimitive( primitive ) {\r\n\r\n\t\tthis._primitives.push( primitive );\r\n\r\n\t}\r\n\r\n}\r\n", "import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { PrimitivePool } from './PrimitivePool.js';\r\n\r\nclass ExtendedTrianglePoolBase extends PrimitivePool {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( () => new ExtendedTriangle() );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\r\n", "class _BufferStack {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.float32Array = null;\r\n\t\tthis.uint16Array = null;\r\n\t\tthis.uint32Array = null;\r\n\r\n\t\tconst stack = [];\r\n\t\tlet prevBuffer = null;\r\n\t\tthis.setBuffer = buffer => {\r\n\r\n\t\t\tif ( prevBuffer ) {\r\n\r\n\t\t\t\tstack.push( prevBuffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevBuffer = buffer;\r\n\t\t\tthis.float32Array = new Float32Array( buffer );\r\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\r\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\r\n\r\n\t\t};\r\n\r\n\t\tthis.clearBuffer = () => {\r\n\r\n\t\t\tprevBuffer = null;\r\n\t\t\tthis.float32Array = null;\r\n\t\t\tthis.uint16Array = null;\r\n\t\t\tthis.uint32Array = null;\r\n\r\n\t\t\tif ( stack.length !== 0 ) {\r\n\r\n\t\t\t\tthis.setBuffer( stack.pop() );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport const BufferStack = new _BufferStack();\r\n", "import { Box3 } from 'three';\r\nimport { CONTAINED } from '../Constants.js';\r\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\r\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\r\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\n\r\nlet _box1, _box2;\r\nconst boxStack = [];\r\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\r\n\r\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\r\n\r\n\t// setup\r\n\t_box1 = boxPool.getPrimitive();\r\n\t_box2 = boxPool.getPrimitive();\r\n\tboxStack.push( _box1, _box2 );\r\n\tBufferStack.setBuffer( bvh._roots[ root ] );\r\n\r\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\r\n\t// cleanup\r\n\tBufferStack.clearBuffer();\r\n\tboxPool.releasePrimitive( _box1 );\r\n\tboxPool.releasePrimitive( _box2 );\r\n\tboxStack.pop();\r\n\tboxStack.pop();\r\n\r\n\tconst length = boxStack.length;\r\n\tif ( length > 0 ) {\r\n\r\n\t\t_box2 = boxStack[ length - 1 ];\r\n\t\t_box1 = boxStack[ length - 2 ];\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction shapecastTraverse(\r\n\tnodeIndex32,\r\n\tgeometry,\r\n\tintersectsBoundsFunc,\r\n\tintersectsRangeFunc,\r\n\tnodeScoreFunc = null,\r\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\r\n\tdepth = 0\r\n) {\r\n\r\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\r\n\tlet nodeIndex16 = nodeIndex32 * 2;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\r\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\r\n\r\n\t} else {\r\n\r\n\t\tconst left = LEFT_NODE( nodeIndex32 );\r\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\tlet c1 = left;\r\n\t\tlet c2 = right;\r\n\r\n\t\tlet score1, score2;\r\n\t\tlet box1, box2;\r\n\t\tif ( nodeScoreFunc ) {\r\n\r\n\t\t\tbox1 = _box1;\r\n\t\t\tbox2 = _box2;\r\n\r\n\t\t\t// bounding data is not offset\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\tscore1 = nodeScoreFunc( box1 );\r\n\t\t\tscore2 = nodeScoreFunc( box2 );\r\n\r\n\t\t\tif ( score2 < score1 ) {\r\n\r\n\t\t\t\tc1 = right;\r\n\t\t\t\tc2 = left;\r\n\r\n\t\t\t\tconst temp = score1;\r\n\t\t\t\tscore1 = score2;\r\n\t\t\t\tscore2 = temp;\r\n\r\n\t\t\t\tbox1 = box2;\r\n\t\t\t\t// box2 is always set before use below\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Check box 1 intersection\r\n\t\tif ( ! box1 ) {\r\n\r\n\t\t\tbox1 = _box1;\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\r\n\t\t}\r\n\r\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\r\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\r\n\r\n\t\tlet c1StopTraversal;\r\n\t\tif ( c1Intersection === CONTAINED ) {\r\n\r\n\t\t\tconst offset = getLeftOffset( c1 );\r\n\t\t\tconst end = getRightEndOffset( c1 );\r\n\t\t\tconst count = end - offset;\r\n\r\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1StopTraversal =\r\n\t\t\t\tc1Intersection &&\r\n\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\tc1,\r\n\t\t\t\t\tgeometry,\r\n\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\tdepth + 1\r\n\t\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( c1StopTraversal ) return true;\r\n\r\n\t\t// Check box 2 intersection\r\n\t\t// cached box2 will have been overwritten by previous traversal\r\n\t\tbox2 = _box2;\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\r\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\r\n\r\n\t\tlet c2StopTraversal;\r\n\t\tif ( c2Intersection === CONTAINED ) {\r\n\r\n\t\t\tconst offset = getLeftOffset( c2 );\r\n\t\t\tconst end = getRightEndOffset( c2 );\r\n\t\t\tconst count = end - offset;\r\n\r\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc2StopTraversal =\r\n\t\t\t\tc2Intersection &&\r\n\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\tc2,\r\n\t\t\t\t\tgeometry,\r\n\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\tdepth + 1\r\n\t\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tif ( c2StopTraversal ) return true;\r\n\r\n\t\treturn false;\r\n\r\n\t\t// Define these inside the function so it has access to the local variables needed\r\n\t\t// when converting to the buffer equivalents\r\n\t\tfunction getLeftOffset( nodeIndex32 ) {\r\n\r\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\r\n\r\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\t// adjust offset to point to the right node\r\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// return the end offset of the triangle range\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Vector3 } from 'three';\r\n\r\nconst temp = /* @__PURE__ */ new Vector3();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\n\r\nexport function closestPointToPoint(\r\n\tbvh,\r\n\tpoint,\r\n\ttarget = { },\r\n\tminThreshold = 0,\r\n\tmaxThreshold = Infinity,\r\n) {\r\n\r\n\t// early out if under minThreshold\r\n\t// skip checking if over maxThreshold\r\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t// returns Infinity if no value found\r\n\tconst minThresholdSq = minThreshold * minThreshold;\r\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\tlet closestDistanceSq = Infinity;\r\n\tlet closestDistanceTriIndex = null;\r\n\tbvh.shapecast(\r\n\r\n\t\t{\r\n\r\n\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\r\n\r\n\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\ttemp1.copy( temp );\r\n\t\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t}\r\n\r\n\t);\r\n\r\n\tif ( closestDistanceSq === Infinity ) return null;\r\n\r\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\r\n\r\n\tif ( ! target.point ) target.point = temp1.clone();\r\n\telse target.point.copy( temp1 );\r\n\ttarget.distance = closestDistance,\r\n\ttarget.faceIndex = closestDistanceTriIndex;\r\n\r\n\treturn target;\r\n\r\n}\r\n", "import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\r\n\r\n// Ripped and modified From THREE.js Mesh raycast\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\r\nconst _vA = /* @__PURE__ */ new Vector3();\r\nconst _vB = /* @__PURE__ */ new Vector3();\r\nconst _vC = /* @__PURE__ */ new Vector3();\r\n\r\nconst _uvA = /* @__PURE__ */ new Vector2();\r\nconst _uvB = /* @__PURE__ */ new Vector2();\r\nconst _uvC = /* @__PURE__ */ new Vector2();\r\n\r\nconst _normalA = /* @__PURE__ */ new Vector3();\r\nconst _normalB = /* @__PURE__ */ new Vector3();\r\nconst _normalC = /* @__PURE__ */ new Vector3();\r\n\r\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\r\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\r\n\r\n\tlet intersect;\r\n\tif ( side === BackSide ) {\r\n\r\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t} else {\r\n\r\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\r\n\r\n\t}\r\n\r\n\tif ( intersect === null ) return null;\r\n\r\n\tconst distance = ray.origin.distanceTo( point );\r\n\r\n\tif ( distance < near || distance > far ) return null;\r\n\r\n\treturn {\r\n\r\n\t\tdistance: distance,\r\n\t\tpoint: point.clone(),\r\n\r\n\t};\r\n\r\n}\r\n\r\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\r\n\r\n\t_vA.fromBufferAttribute( position, a );\r\n\t_vB.fromBufferAttribute( position, b );\r\n\t_vC.fromBufferAttribute( position, c );\r\n\r\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tif ( uv ) {\r\n\r\n\t\t\t_uvA.fromBufferAttribute( uv, a );\r\n\t\t\t_uvB.fromBufferAttribute( uv, b );\r\n\t\t\t_uvC.fromBufferAttribute( uv, c );\r\n\r\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\r\n\r\n\t\t}\r\n\r\n\t\tif ( uv1 ) {\r\n\r\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\r\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\r\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\r\n\r\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\r\n\r\n\t\t}\r\n\r\n\t\tif ( normal ) {\r\n\r\n\t\t\t_normalA.fromBufferAttribute( normal, a );\r\n\t\t\t_normalB.fromBufferAttribute( normal, b );\r\n\t\t\t_normalC.fromBufferAttribute( normal, c );\r\n\r\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\r\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\r\n\r\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst face = {\r\n\t\t\ta: a,\r\n\t\t\tb: b,\r\n\t\t\tc: c,\r\n\t\t\tnormal: new Vector3(),\r\n\t\t\tmaterialIndex: 0\r\n\t\t};\r\n\r\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\r\n\r\n\t\tintersection.face = face;\r\n\t\tintersection.faceIndex = a;\r\n\r\n\t}\r\n\r\n\treturn intersection;\r\n\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\r\nfunction intersectTri( geo, side, ray, tri, intersections, near, far ) {\r\n\r\n\tconst triOffset = tri * 3;\r\n\tlet a = triOffset + 0;\r\n\tlet b = triOffset + 1;\r\n\tlet c = triOffset + 2;\r\n\r\n\tconst index = geo.index;\r\n\tif ( geo.index ) {\r\n\r\n\t\ta = index.getX( a );\r\n\t\tb = index.getX( b );\r\n\t\tc = index.getX( c );\r\n\r\n\t}\r\n\r\n\tconst { position, normal, uv, uv1 } = geo.attributes;\r\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\r\n\r\n\tif ( intersection ) {\r\n\r\n\t\tintersection.faceIndex = tri;\r\n\t\tif ( intersections ) intersections.push( intersection );\r\n\t\treturn intersection;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\nexport { intersectTri };\r\n", "\r\nimport { Vector2, Vector3, Triangle } from 'three';\r\n\r\n// sets the vertices of triangle `tri` with the 3 vertices after i\r\nexport function setTriangle( tri, i, index, pos ) {\r\n\r\n\tconst ta = tri.a;\r\n\tconst tb = tri.b;\r\n\tconst tc = tri.c;\r\n\r\n\tlet i0 = i;\r\n\tlet i1 = i + 1;\r\n\tlet i2 = i + 2;\r\n\tif ( index ) {\r\n\r\n\t\ti0 = index.getX( i0 );\r\n\t\ti1 = index.getX( i1 );\r\n\t\ti2 = index.getX( i2 );\r\n\r\n\t}\r\n\r\n\tta.x = pos.getX( i0 );\r\n\tta.y = pos.getY( i0 );\r\n\tta.z = pos.getZ( i0 );\r\n\r\n\ttb.x = pos.getX( i1 );\r\n\ttb.y = pos.getY( i1 );\r\n\ttb.z = pos.getZ( i1 );\r\n\r\n\ttc.x = pos.getX( i2 );\r\n\ttc.y = pos.getY( i2 );\r\n\ttc.z = pos.getZ( i2 );\r\n\r\n}\r\n\r\nconst tempV1 = /* @__PURE__ */ new Vector3();\r\nconst tempV2 = /* @__PURE__ */ new Vector3();\r\nconst tempV3 = /* @__PURE__ */ new Vector3();\r\nconst tempUV1 = /* @__PURE__ */ new Vector2();\r\nconst tempUV2 = /* @__PURE__ */ new Vector2();\r\nconst tempUV3 = /* @__PURE__ */ new Vector2();\r\n\r\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\r\n\r\n\tconst indices = geometry.getIndex().array;\r\n\tconst positions = geometry.getAttribute( 'position' );\r\n\tconst uvs = geometry.getAttribute( 'uv' );\r\n\r\n\tconst a = indices[ triangleIndex * 3 ];\r\n\tconst b = indices[ triangleIndex * 3 + 1 ];\r\n\tconst c = indices[ triangleIndex * 3 + 2 ];\r\n\r\n\ttempV1.fromBufferAttribute( positions, a );\r\n\ttempV2.fromBufferAttribute( positions, b );\r\n\ttempV3.fromBufferAttribute( positions, c );\r\n\r\n\t// find the associated material index\r\n\tlet materialIndex = 0;\r\n\tconst groups = geometry.groups;\r\n\tconst firstVertexIndex = triangleIndex * 3;\r\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst { start, count } = group;\r\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\r\n\r\n\t\t\tmaterialIndex = group.materialIndex;\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// extract uvs\r\n\tlet uv = null;\r\n\tif ( uvs ) {\r\n\r\n\t\ttempUV1.fromBufferAttribute( uvs, a );\r\n\t\ttempUV2.fromBufferAttribute( uvs, b );\r\n\t\ttempUV3.fromBufferAttribute( uvs, c );\r\n\r\n\t\tif ( target && target.uv ) uv = target.uv;\r\n\t\telse uv = new Vector2();\r\n\r\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\r\n\r\n\t}\r\n\r\n\t// adjust the provided target or create a new one\r\n\tif ( target ) {\r\n\r\n\t\tif ( ! target.face ) target.face = { };\r\n\t\ttarget.face.a = a;\r\n\t\ttarget.face.b = b;\r\n\t\ttarget.face.c = c;\r\n\t\ttarget.face.materialIndex = materialIndex;\r\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\r\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\r\n\r\n\t\tif ( uv ) target.uv = uv;\r\n\r\n\t\treturn target;\r\n\r\n\t} else {\r\n\r\n\t\treturn {\r\n\t\t\tface: {\r\n\t\t\t\ta: a,\r\n\t\t\t\tb: b,\r\n\t\t\t\tc: c,\r\n\t\t\t\tmaterialIndex: materialIndex,\r\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\r\n\t\t\t},\r\n\t\t\tuv: uv\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n", "import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\r\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\r\n\r\n/*************************************************************/\r\n/* This file is generated from \"iterationUtils.template.js\". */\r\n/*************************************************************/\r\n/* eslint-disable indent */\r\n\r\nfunction intersectTris( bvh, side, ray, offset, count, intersections, near, far ) {\r\n\r\n\tconst { geometry, _indirectBuffer } = bvh;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\r\n\t\tintersectTri( geometry, side, ray, i, intersections, near, far );\r\n\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction intersectClosestTri( bvh, side, ray, offset, count, near, far ) {\r\n\r\n\tconst { geometry, _indirectBuffer } = bvh;\r\n\tlet dist = Infinity;\r\n\tlet res = null;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tlet intersection;\r\n\r\n\t\tintersection = intersectTri( geometry, side, ray, i, null, near, far );\r\n\r\n\r\n\t\tif ( intersection && intersection.distance < dist ) {\r\n\r\n\t\t\tres = intersection;\r\n\t\t\tdist = intersection.distance;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\nfunction iterateOverTriangles(\r\n\toffset,\r\n\tcount,\r\n\tbvh,\r\n\tintersectsTriangleFunc,\r\n\tcontained,\r\n\tdepth,\r\n\ttriangle\r\n) {\r\n\r\n\tconst { geometry } = bvh;\r\n\tconst { index } = geometry;\r\n\tconst pos = geometry.attributes.position;\r\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\r\n\r\n\t\tlet tri;\r\n\r\n\t\ttri = i;\r\n\r\n\t\tsetTriangle( triangle, tri * 3, index, pos );\r\n\t\ttriangle.needsUpdate = true;\r\n\r\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\r\n", "import { IS_LEAFNODE_FLAG } from '../Constants.js';\r\n\r\n/****************************************************/\r\n/* This file is generated from \"refit.template.js\". */\r\n/****************************************************/\r\n\r\nfunction refit( bvh, nodeIndices = null ) {\r\n\r\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t}\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tconst indexArr = geometry.index ? geometry.index.array : null;\r\n\tconst posAttr = geometry.attributes.position;\r\n\r\n\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\tlet byteOffset = 0;\r\n\tconst roots = bvh._roots;\r\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\tbuffer = roots[ i ];\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t_traverse( 0, byteOffset );\r\n\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t}\r\n\r\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\tconst node16Index = node32Index * 2;\r\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\tlet minx = Infinity;\r\n\t\t\tlet miny = Infinity;\r\n\t\t\tlet minz = Infinity;\r\n\t\t\tlet maxx = - Infinity;\r\n\t\t\tlet maxy = - Infinity;\r\n\t\t\tlet maxz = - Infinity;\r\n\r\n\r\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\tlet index = indexArr[ i ];\r\n\t\t\t\tconst x = posAttr.getX( index );\r\n\t\t\t\tconst y = posAttr.getY( index );\r\n\t\t\t\tconst z = posAttr.getZ( index );\r\n\r\n\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (\r\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t) {\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node32Index + 8;\r\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\tconst offsetRight = right + byteOffset;\r\n\t\t\tlet forceChildren = force;\r\n\t\t\tlet includesLeft = false;\r\n\t\t\tlet includesRight = false;\r\n\r\n\t\t\tif ( nodeIndices ) {\r\n\r\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\r\n\t\t\t\t// then we assume that all children need to be updated.\r\n\t\t\t\tif ( ! forceChildren ) {\r\n\r\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\r\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\r\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tincludesLeft = true;\r\n\t\t\t\tincludesRight = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\r\n\t\t\tconst traverseRight = forceChildren || includesRight;\r\n\r\n\t\t\tlet leftChange = false;\r\n\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet rightChange = false;\r\n\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst didChange = leftChange || rightChange;\r\n\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn didChange;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { refit };\r\n", "/**\r\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\r\n * with the difference that the box values are read from an array to improve performance.\r\n */\r\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\r\n\r\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\tconst invdirx = 1 / ray.direction.x,\r\n\t\tinvdiry = 1 / ray.direction.y,\r\n\t\tinvdirz = 1 / ray.direction.z;\r\n\r\n\tconst ox = ray.origin.x;\r\n\tconst oy = ray.origin.y;\r\n\tconst oz = ray.origin.z;\r\n\r\n\tlet minx = array[ nodeIndex32 ];\r\n\tlet maxx = array[ nodeIndex32 + 3 ];\r\n\r\n\tlet miny = array[ nodeIndex32 + 1 ];\r\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\r\n\r\n\tlet minz = array[ nodeIndex32 + 2 ];\r\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\r\n\r\n\tif ( invdirx >= 0 ) {\r\n\r\n\t\ttmin = ( minx - ox ) * invdirx;\r\n\t\ttmax = ( maxx - ox ) * invdirx;\r\n\r\n\t} else {\r\n\r\n\t\ttmin = ( maxx - ox ) * invdirx;\r\n\t\ttmax = ( minx - ox ) * invdirx;\r\n\r\n\t}\r\n\r\n\tif ( invdiry >= 0 ) {\r\n\r\n\t\ttymin = ( miny - oy ) * invdiry;\r\n\t\ttymax = ( maxy - oy ) * invdiry;\r\n\r\n\t} else {\r\n\r\n\t\ttymin = ( maxy - oy ) * invdiry;\r\n\t\ttymax = ( miny - oy ) * invdiry;\r\n\r\n\t}\r\n\r\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\r\n\r\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\r\n\r\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\r\n\r\n\tif ( invdirz >= 0 ) {\r\n\r\n\t\ttzmin = ( minz - oz ) * invdirz;\r\n\t\ttzmax = ( maxz - oz ) * invdirz;\r\n\r\n\t} else {\r\n\r\n\t\ttzmin = ( maxz - oz ) * invdirz;\r\n\t\ttzmax = ( minz - oz ) * invdirz;\r\n\r\n\t}\r\n\r\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\r\n\r\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t//return point closest to the ray (positive side)\r\n\r\n\treturn tmin <= far && tmax >= near;\r\n\r\n}\r\n", "import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\r\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\r\n\r\n/*************************************************************/\r\n/* This file is generated from \"iterationUtils.template.js\". */\r\n/*************************************************************/\r\n/* eslint-disable indent */\r\n\r\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections, near, far ) {\r\n\r\n\tconst { geometry, _indirectBuffer } = bvh;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\r\n\t\tintersectTri( geometry, side, ray, vi, intersections, near, far );\r\n\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far ) {\r\n\r\n\tconst { geometry, _indirectBuffer } = bvh;\r\n\tlet dist = Infinity;\r\n\tlet res = null;\r\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\r\n\r\n\t\tlet intersection;\r\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\r\n\r\n\r\n\t\tif ( intersection && intersection.distance < dist ) {\r\n\r\n\t\t\tres = intersection;\r\n\t\t\tdist = intersection.distance;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\nfunction iterateOverTriangles_indirect(\r\n\toffset,\r\n\tcount,\r\n\tbvh,\r\n\tintersectsTriangleFunc,\r\n\tcontained,\r\n\tdepth,\r\n\ttriangle\r\n) {\r\n\r\n\tconst { geometry } = bvh;\r\n\tconst { index } = geometry;\r\n\tconst pos = geometry.attributes.position;\r\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\r\n\r\n\t\tlet tri;\r\n\t\ttri = bvh.resolveTriangleIndex( i );\r\n\r\n\t\tsetTriangle( triangle, tri * 3, index, pos );\r\n\t\ttriangle.needsUpdate = true;\r\n\r\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\r\n", "import { intersectRay } from '../utils/intersectUtils.js';\r\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\r\nimport '../utils/iterationUtils_indirect.generated.js';\r\n\r\n/******************************************************/\r\n/* This file is generated from \"raycast.template.js\". */\r\n/******************************************************/\r\n\r\nfunction raycast( bvh, root, side, ray, intersects, near, far ) {\r\n\r\n\tBufferStack.setBuffer( bvh._roots[ root ] );\r\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\r\n\tBufferStack.clearBuffer();\r\n\r\n}\r\n\r\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\r\n\r\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\r\n\tconst nodeIndex16 = nodeIndex32 * 2;\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\r\n\t\tintersectTris( bvh, side, ray, offset, count, intersects, near, far );\r\n\r\n\r\n\t} else {\r\n\r\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\r\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\r\n\r\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\r\n\r\n\t\t}\r\n\r\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\r\n\r\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { raycast };\r\n", "import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\nimport { intersectRay } from '../utils/intersectUtils.js';\r\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\r\nimport '../utils/iterationUtils_indirect.generated.js';\r\n\r\n/***********************************************************/\r\n/* This file is generated from \"raycastFirst.template.js\". */\r\n/***********************************************************/\r\n\r\nconst _xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nfunction raycastFirst( bvh, root, side, ray, near, far ) {\r\n\r\n\tBufferStack.setBuffer( bvh._roots[ root ] );\r\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\r\n\tBufferStack.clearBuffer();\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\r\n\r\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\r\n\tlet nodeIndex16 = nodeIndex32 * 2;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\r\n\t\t// eslint-disable-next-line no-unreachable\r\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count, near, far );\r\n\r\n\r\n\t} else {\r\n\r\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\r\n\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t// c1 is the child to check first\r\n\t\tlet c1, c2;\r\n\t\tif ( leftToRight ) {\r\n\r\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\r\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\r\n\r\n\t\t}\r\n\r\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\r\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\r\n\r\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\tif ( c1Result ) {\r\n\r\n\t\t\t// check if the point is within the second bounds\r\n\t\t\t// \"point\" is in the local frame of the bvh\r\n\t\t\tconst point = c1Result.point[ xyzAxis ];\r\n\t\t\tconst isOutside = leftToRight ?\r\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\r\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\r\n\r\n\t\t\tif ( isOutside ) {\r\n\r\n\t\t\t\treturn c1Result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\r\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\r\n\r\n\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { raycastFirst };\r\n", "import { Box3, Matrix4 } from 'three';\r\nimport { OrientedBox } from '../../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\r\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\r\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\r\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\n\r\n/*****************************************************************/\r\n/* This file is generated from \"intersectsGeometry.template.js\". */\r\n/*****************************************************************/\r\n/* eslint-disable indent */\r\n\r\nconst boundingBox = /* @__PURE__ */ new Box3();\r\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\r\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\r\nconst invertedMat = /* @__PURE__ */ new Matrix4();\r\n\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\n\r\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\r\n\r\n\tBufferStack.setBuffer( bvh._roots[ root ] );\r\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\r\n\tBufferStack.clearBuffer();\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\r\n\tlet nodeIndex16 = nodeIndex32 * 2;\r\n\r\n\tif ( cachedObb === null ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tcachedObb = obb;\r\n\r\n\t}\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst thisGeometry = bvh.geometry;\r\n\t\tconst thisIndex = thisGeometry.index;\r\n\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\tconst index = otherGeometry.index;\r\n\t\tconst pos = otherGeometry.attributes.position;\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t// here.\r\n\t\tinvertedMat.copy( geometryToBvh ).invert();\r\n\r\n\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t// if there's a bounds tree\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\r\n\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t// TODO: use a triangle iteration function here\r\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\r\n\r\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\r\n\r\n\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.needsUpdate = true;\r\n\r\n\r\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\r\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn res;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// if we're just dealing with raw geometry\r\n\r\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\r\n\r\n\r\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst left = nodeIndex32 + 8;\r\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\r\n\t\tconst leftIntersection =\r\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\tif ( leftIntersection ) return true;\r\n\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\r\n\t\tconst rightIntersection =\r\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\tif ( rightIntersection ) return true;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { intersectsGeometry };\r\n", "import { Matrix4, Vector3 } from 'three';\r\nimport { OrientedBox } from '../../math/OrientedBox.js';\r\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\r\nimport { getTriCount } from '../build/geometryUtils.js';\r\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\r\n\r\n/*********************************************************************/\r\n/* This file is generated from \"closestPointToGeometry.template.js\". */\r\n/*********************************************************************/\r\n\r\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\nconst temp2 = /* @__PURE__ */ new Vector3();\r\nconst temp3 = /* @__PURE__ */ new Vector3();\r\nconst temp4 = /* @__PURE__ */ new Vector3();\r\n\r\nfunction closestPointToGeometry(\r\n\tbvh,\r\n\totherGeometry,\r\n\tgeometryToBvh,\r\n\ttarget1 = { },\r\n\ttarget2 = { },\r\n\tminThreshold = 0,\r\n\tmaxThreshold = Infinity,\r\n) {\r\n\r\n\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\totherGeometry.computeBoundingBox();\r\n\r\n\t}\r\n\r\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\tobb.needsUpdate = true;\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tconst pos = geometry.attributes.position;\r\n\tconst index = geometry.index;\r\n\tconst otherPos = otherGeometry.attributes.position;\r\n\tconst otherIndex = otherGeometry.index;\r\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\r\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\r\n\r\n\tlet tempTarget1 = temp1;\r\n\tlet tempTargetDest1 = temp2;\r\n\tlet tempTarget2 = null;\r\n\tlet tempTargetDest2 = null;\r\n\r\n\tif ( target2 ) {\r\n\r\n\t\ttempTarget2 = temp3;\r\n\t\ttempTargetDest2 = temp4;\r\n\r\n\t}\r\n\r\n\tlet closestDistance = Infinity;\r\n\tlet closestDistanceTriIndex = null;\r\n\tlet closestDistanceOtherTriIndex = null;\r\n\ttempMatrix.copy( geometryToBvh ).invert();\r\n\tobb2.matrix.copy( tempMatrix );\r\n\tbvh.shapecast(\r\n\t\t{\r\n\r\n\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\treturn obb.distanceToBox( box );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\r\n\t\t\t\t\treturn otherBvh.shapecast( {\r\n\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\r\n\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\r\n\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\r\n\r\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\r\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\r\n\r\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\r\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\r\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\r\n\r\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\r\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t}\r\n\r\n\t);\r\n\r\n\tExtendedTrianglePool.releasePrimitive( triangle );\r\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\r\n\r\n\tif ( closestDistance === Infinity ) {\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tif ( ! target1.point ) {\r\n\r\n\t\ttarget1.point = tempTargetDest1.clone();\r\n\r\n\t} else {\r\n\r\n\t\ttarget1.point.copy( tempTargetDest1 );\r\n\r\n\t}\r\n\r\n\ttarget1.distance = closestDistance,\r\n\ttarget1.faceIndex = closestDistanceTriIndex;\r\n\r\n\tif ( target2 ) {\r\n\r\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\r\n\t\telse target2.point.copy( tempTargetDest2 );\r\n\t\ttarget2.point.applyMatrix4( tempMatrix );\r\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\r\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\r\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\r\n\r\n\t}\r\n\r\n\treturn target1;\r\n\r\n}\r\n\r\nexport { closestPointToGeometry };\r\n", "import { IS_LEAFNODE_FLAG } from '../Constants.js';\r\n\r\n/****************************************************/\r\n/* This file is generated from \"refit.template.js\". */\r\n/****************************************************/\r\n\r\nfunction refit_indirect( bvh, nodeIndices = null ) {\r\n\r\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t}\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tconst indexArr = geometry.index ? geometry.index.array : null;\r\n\tconst posAttr = geometry.attributes.position;\r\n\r\n\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\tlet byteOffset = 0;\r\n\tconst roots = bvh._roots;\r\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\tbuffer = roots[ i ];\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t_traverse( 0, byteOffset );\r\n\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t}\r\n\r\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\tconst node16Index = node32Index * 2;\r\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\tlet minx = Infinity;\r\n\t\t\tlet miny = Infinity;\r\n\t\t\tlet minz = Infinity;\r\n\t\t\tlet maxx = - Infinity;\r\n\t\t\tlet maxy = - Infinity;\r\n\t\t\tlet maxz = - Infinity;\r\n\r\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\r\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tlet index = t + j;\r\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\r\n\r\n\t\t\t\t\tconst x = posAttr.getX( index );\r\n\t\t\t\t\tconst y = posAttr.getY( index );\r\n\t\t\t\t\tconst z = posAttr.getZ( index );\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (\r\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t) {\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node32Index + 8;\r\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\tconst offsetRight = right + byteOffset;\r\n\t\t\tlet forceChildren = force;\r\n\t\t\tlet includesLeft = false;\r\n\t\t\tlet includesRight = false;\r\n\r\n\t\t\tif ( nodeIndices ) {\r\n\r\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\r\n\t\t\t\t// then we assume that all children need to be updated.\r\n\t\t\t\tif ( ! forceChildren ) {\r\n\r\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\r\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\r\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tincludesLeft = true;\r\n\t\t\t\tincludesRight = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\r\n\t\t\tconst traverseRight = forceChildren || includesRight;\r\n\r\n\t\t\tlet leftChange = false;\r\n\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet rightChange = false;\r\n\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst didChange = leftChange || rightChange;\r\n\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn didChange;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { refit_indirect };\r\n", "import { intersectRay } from '../utils/intersectUtils.js';\r\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\nimport '../utils/iterationUtils.generated.js';\r\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\r\n\r\n/******************************************************/\r\n/* This file is generated from \"raycast.template.js\". */\r\n/******************************************************/\r\n\r\nfunction raycast_indirect( bvh, root, side, ray, intersects, near, far ) {\r\n\r\n\tBufferStack.setBuffer( bvh._roots[ root ] );\r\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\r\n\tBufferStack.clearBuffer();\r\n\r\n}\r\n\r\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\r\n\r\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\r\n\tconst nodeIndex16 = nodeIndex32 * 2;\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects, near, far );\r\n\r\n\r\n\t} else {\r\n\r\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\r\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\r\n\r\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\r\n\r\n\t\t}\r\n\r\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\r\n\r\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { raycast_indirect };\r\n", "import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\nimport { intersectRay } from '../utils/intersectUtils.js';\r\nimport '../utils/iterationUtils.generated.js';\r\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\r\n\r\n/***********************************************************/\r\n/* This file is generated from \"raycastFirst.template.js\". */\r\n/***********************************************************/\r\n\r\nconst _xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nfunction raycastFirst_indirect( bvh, root, side, ray, near, far ) {\r\n\r\n\tBufferStack.setBuffer( bvh._roots[ root ] );\r\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\r\n\tBufferStack.clearBuffer();\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\r\n\r\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\r\n\tlet nodeIndex16 = nodeIndex32 * 2;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far );\r\n\r\n\r\n\t} else {\r\n\r\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\r\n\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t// c1 is the child to check first\r\n\t\tlet c1, c2;\r\n\t\tif ( leftToRight ) {\r\n\r\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\r\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\r\n\r\n\t\t}\r\n\r\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\r\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\r\n\r\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\tif ( c1Result ) {\r\n\r\n\t\t\t// check if the point is within the second bounds\r\n\t\t\t// \"point\" is in the local frame of the bvh\r\n\t\t\tconst point = c1Result.point[ xyzAxis ];\r\n\t\t\tconst isOutside = leftToRight ?\r\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\r\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\r\n\r\n\t\t\tif ( isOutside ) {\r\n\r\n\t\t\t\treturn c1Result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\r\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\r\n\r\n\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { raycastFirst_indirect };\r\n", "import { Box3, Matrix4 } from 'three';\r\nimport { OrientedBox } from '../../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\r\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\r\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\r\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\n\r\n/*****************************************************************/\r\n/* This file is generated from \"intersectsGeometry.template.js\". */\r\n/*****************************************************************/\r\n/* eslint-disable indent */\r\n\r\nconst boundingBox = /* @__PURE__ */ new Box3();\r\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\r\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\r\nconst invertedMat = /* @__PURE__ */ new Matrix4();\r\n\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\n\r\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\r\n\r\n\tBufferStack.setBuffer( bvh._roots[ root ] );\r\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\r\n\tBufferStack.clearBuffer();\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\r\n\tlet nodeIndex16 = nodeIndex32 * 2;\r\n\r\n\tif ( cachedObb === null ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tcachedObb = obb;\r\n\r\n\t}\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst thisGeometry = bvh.geometry;\r\n\t\tconst thisIndex = thisGeometry.index;\r\n\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\tconst index = otherGeometry.index;\r\n\t\tconst pos = otherGeometry.attributes.position;\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t// here.\r\n\t\tinvertedMat.copy( geometryToBvh ).invert();\r\n\r\n\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t// if there's a bounds tree\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\r\n\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t// TODO: use a triangle iteration function here\r\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\r\n\r\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\r\n\r\n\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\ttri.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\r\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn res;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// if we're just dealing with raw geometry\r\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\r\n\r\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\r\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\r\n\r\n\r\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst left = nodeIndex32 + 8;\r\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\r\n\t\tconst leftIntersection =\r\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\tif ( leftIntersection ) return true;\r\n\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\r\n\t\tconst rightIntersection =\r\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\tif ( rightIntersection ) return true;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { intersectsGeometry_indirect };\r\n", "import { Matrix4, Vector3 } from 'three';\r\nimport { OrientedBox } from '../../math/OrientedBox.js';\r\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\r\nimport { getTriCount } from '../build/geometryUtils.js';\r\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\r\n\r\n/*********************************************************************/\r\n/* This file is generated from \"closestPointToGeometry.template.js\". */\r\n/*********************************************************************/\r\n\r\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\nconst temp2 = /* @__PURE__ */ new Vector3();\r\nconst temp3 = /* @__PURE__ */ new Vector3();\r\nconst temp4 = /* @__PURE__ */ new Vector3();\r\n\r\nfunction closestPointToGeometry_indirect(\r\n\tbvh,\r\n\totherGeometry,\r\n\tgeometryToBvh,\r\n\ttarget1 = { },\r\n\ttarget2 = { },\r\n\tminThreshold = 0,\r\n\tmaxThreshold = Infinity,\r\n) {\r\n\r\n\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\totherGeometry.computeBoundingBox();\r\n\r\n\t}\r\n\r\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\tobb.needsUpdate = true;\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tconst pos = geometry.attributes.position;\r\n\tconst index = geometry.index;\r\n\tconst otherPos = otherGeometry.attributes.position;\r\n\tconst otherIndex = otherGeometry.index;\r\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\r\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\r\n\r\n\tlet tempTarget1 = temp1;\r\n\tlet tempTargetDest1 = temp2;\r\n\tlet tempTarget2 = null;\r\n\tlet tempTargetDest2 = null;\r\n\r\n\tif ( target2 ) {\r\n\r\n\t\ttempTarget2 = temp3;\r\n\t\ttempTargetDest2 = temp4;\r\n\r\n\t}\r\n\r\n\tlet closestDistance = Infinity;\r\n\tlet closestDistanceTriIndex = null;\r\n\tlet closestDistanceOtherTriIndex = null;\r\n\ttempMatrix.copy( geometryToBvh ).invert();\r\n\tobb2.matrix.copy( tempMatrix );\r\n\tbvh.shapecast(\r\n\t\t{\r\n\r\n\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\treturn obb.distanceToBox( box );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\r\n\t\t\t\t\treturn otherBvh.shapecast( {\r\n\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\r\n\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\r\n\r\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\r\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\r\n\r\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\r\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\r\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\r\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\r\n\r\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\r\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t}\r\n\r\n\t);\r\n\r\n\tExtendedTrianglePool.releasePrimitive( triangle );\r\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\r\n\r\n\tif ( closestDistance === Infinity ) {\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\tif ( ! target1.point ) {\r\n\r\n\t\ttarget1.point = tempTargetDest1.clone();\r\n\r\n\t} else {\r\n\r\n\t\ttarget1.point.copy( tempTargetDest1 );\r\n\r\n\t}\r\n\r\n\ttarget1.distance = closestDistance,\r\n\ttarget1.faceIndex = closestDistanceTriIndex;\r\n\r\n\tif ( target2 ) {\r\n\r\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\r\n\t\telse target2.point.copy( tempTargetDest2 );\r\n\t\ttarget2.point.applyMatrix4( tempMatrix );\r\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\r\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\r\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\r\n\r\n\t}\r\n\r\n\treturn target1;\r\n\r\n}\r\n\r\nexport { closestPointToGeometry_indirect };\r\n", "export function isSharedArrayBufferSupported() {\r\n\r\n\treturn typeof SharedArrayBuffer !== 'undefined';\r\n\r\n}\r\n\r\nexport function convertToBufferType( array, BufferConstructor ) {\r\n\r\n\tif ( array === null ) {\r\n\r\n\t\treturn array;\r\n\r\n\t} else if ( array.buffer ) {\r\n\r\n\t\tconst buffer = array.buffer;\r\n\t\tif ( buffer.constructor === BufferConstructor ) {\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\tconst ArrayConstructor = array.constructor;\r\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\r\n\t\tresult.set( array );\r\n\t\treturn result;\r\n\r\n\t} else {\r\n\r\n\t\tif ( array.constructor === BufferConstructor ) {\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t}\r\n\r\n\t\tconst result = new BufferConstructor( array.byteLength );\r\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n", "import { Box3, Matrix4 } from 'three';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\r\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\r\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\r\n\r\nconst _bufferStack1 = new BufferStack.constructor();\r\nconst _bufferStack2 = new BufferStack.constructor();\r\nconst _boxPool = new PrimitivePool( () => new Box3() );\r\nconst _leftBox1 = new Box3();\r\nconst _rightBox1 = new Box3();\r\n\r\nconst _leftBox2 = new Box3();\r\nconst _rightBox2 = new Box3();\r\n\r\nlet _active = false;\r\n\r\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\r\n\r\n\tif ( _active ) {\r\n\r\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\r\n\r\n\t}\r\n\r\n\t_active = true;\r\n\r\n\tconst roots = bvh._roots;\r\n\tconst otherRoots = otherBvh._roots;\r\n\tlet result;\r\n\tlet offset1 = 0;\r\n\tlet offset2 = 0;\r\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\r\n\r\n\t// iterate over the first set of roots\r\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\r\n\r\n\t\t_bufferStack1.setBuffer( roots[ i ] );\r\n\t\toffset2 = 0;\r\n\r\n\t\t// prep the initial root box\r\n\t\tconst localBox = _boxPool.getPrimitive();\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\r\n\t\tlocalBox.applyMatrix4( invMat );\r\n\r\n\t\t// iterate over the second set of roots\r\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\r\n\r\n\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\r\n\r\n\t\t\tresult = _traverse(\r\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\r\n\t\t\t\toffset1, offset2, 0, 0,\r\n\t\t\t\tlocalBox,\r\n\t\t\t);\r\n\r\n\t\t\t_bufferStack2.clearBuffer();\r\n\t\t\toffset2 += otherRoots[ j ].length;\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// release stack info\r\n\t\t_boxPool.releasePrimitive( localBox );\r\n\t\t_bufferStack1.clearBuffer();\r\n\t\toffset1 += roots[ i ].length;\r\n\r\n\t\tif ( result ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_active = false;\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction _traverse(\r\n\tnode1Index32,\r\n\tnode2Index32,\r\n\tmatrix2to1,\r\n\tmatrix1to2,\r\n\tintersectsRangesFunc,\r\n\r\n\t// offsets for ids\r\n\tnode1IndexByteOffset = 0,\r\n\tnode2IndexByteOffset = 0,\r\n\r\n\t// tree depth\r\n\tdepth1 = 0,\r\n\tdepth2 = 0,\r\n\r\n\tcurrBox = null,\r\n\treversed = false,\r\n\r\n) {\r\n\r\n\t// get the buffer stacks associated with the current indices\r\n\tlet bufferStack1, bufferStack2;\r\n\tif ( reversed ) {\r\n\r\n\t\tbufferStack1 = _bufferStack2;\r\n\t\tbufferStack2 = _bufferStack1;\r\n\r\n\t} else {\r\n\r\n\t\tbufferStack1 = _bufferStack1;\r\n\t\tbufferStack2 = _bufferStack2;\r\n\r\n\t}\r\n\r\n\t// get the local instances of the typed buffers\r\n\tconst\r\n\t\tfloat32Array1 = bufferStack1.float32Array,\r\n\t\tuint32Array1 = bufferStack1.uint32Array,\r\n\t\tuint16Array1 = bufferStack1.uint16Array,\r\n\t\tfloat32Array2 = bufferStack2.float32Array,\r\n\t\tuint32Array2 = bufferStack2.uint32Array,\r\n\t\tuint16Array2 = bufferStack2.uint16Array;\r\n\r\n\tconst node1Index16 = node1Index32 * 2;\r\n\tconst node2Index16 = node2Index32 * 2;\r\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\r\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\r\n\tlet result = false;\r\n\tif ( isLeaf2 && isLeaf1 ) {\r\n\r\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\r\n\t\tif ( reversed ) {\r\n\r\n\t\t\tresult = intersectsRangesFunc(\r\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\r\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\r\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\r\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\r\n\t\t\t);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = intersectsRangesFunc(\r\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\r\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\r\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\r\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t} else if ( isLeaf2 ) {\r\n\r\n\t\t// SWAP\r\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\r\n\t\t// to traverse down the first one\r\n\r\n\t\t// get the new box to use\r\n\t\tconst newBox = _boxPool.getPrimitive();\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\r\n\t\tnewBox.applyMatrix4( matrix2to1 );\r\n\r\n\t\t// get the child bounds to check before traversal\r\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\r\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\r\n\r\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\r\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\r\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\r\n\t\tresult = (\r\n\t\t\tintersectCl1 && _traverse(\r\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\r\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\r\n\t\t\t\tnewBox, ! reversed,\r\n\t\t\t)\r\n\t\t) || (\r\n\t\t\tintersectCr1 && _traverse(\r\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\r\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\r\n\t\t\t\tnewBox, ! reversed,\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t\t_boxPool.releasePrimitive( newBox );\r\n\r\n\t} else {\r\n\r\n\t\t// if neither are leaves then we should swap if one of the children does not\r\n\t\t// intersect with the current bounds\r\n\r\n\t\t// get the child bounds to check\r\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\r\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\r\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\r\n\r\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\r\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\r\n\t\tif ( leftIntersects && rightIntersects ) {\r\n\r\n\t\t\t// continue to traverse both children if they both intersect\r\n\t\t\tresult = _traverse(\r\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\r\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\r\n\t\t\t\tcurrBox, reversed,\r\n\t\t\t) || _traverse(\r\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\r\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\r\n\t\t\t\tcurrBox, reversed,\r\n\t\t\t);\r\n\r\n\t\t} else if ( leftIntersects ) {\r\n\r\n\t\t\tif ( isLeaf1 ) {\r\n\r\n\t\t\t\t// if the current box is a leaf then just continue\r\n\t\t\t\tresult = _traverse(\r\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\r\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\r\n\t\t\t\t\tcurrBox, reversed,\r\n\t\t\t\t);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// SWAP\r\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\r\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\r\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\r\n\r\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\r\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\r\n\r\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\r\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\r\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\r\n\t\t\t\tresult = (\r\n\t\t\t\t\tintersectCl1 && _traverse(\r\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\r\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\r\n\t\t\t\t\t\tnewBox, ! reversed,\r\n\t\t\t\t\t)\r\n\t\t\t\t) || (\r\n\t\t\t\t\tintersectCr1 && _traverse(\r\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\r\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\r\n\t\t\t\t\t\tnewBox, ! reversed,\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_boxPool.releasePrimitive( newBox );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( rightIntersects ) {\r\n\r\n\t\t\tif ( isLeaf1 ) {\r\n\r\n\t\t\t\t// if the current box is a leaf then just continue\r\n\t\t\t\tresult = _traverse(\r\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\r\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\r\n\t\t\t\t\tcurrBox, reversed,\r\n\t\t\t\t);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// SWAP\r\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\r\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\r\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\r\n\r\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\r\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\r\n\r\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\r\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\r\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\r\n\t\t\t\tresult = (\r\n\t\t\t\t\tintersectCl1 && _traverse(\r\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\r\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\r\n\t\t\t\t\t\tnewBox, ! reversed,\r\n\t\t\t\t\t)\r\n\t\t\t\t) || (\r\n\t\t\t\t\tintersectCr1 && _traverse(\r\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\r\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\r\n\t\t\t\t\t\tnewBox, ! reversed,\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_boxPool.releasePrimitive( newBox );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n", "import { BufferAttribute, Box3, FrontSide } from 'three';\r\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\r\nimport { buildPackedTree } from './build/buildTree.js';\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\r\nimport { shapecast } from './cast/shapecast.js';\r\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\r\n\r\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\r\nimport { refit } from './cast/refit.generated.js';\r\nimport { raycast } from './cast/raycast.generated.js';\r\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\r\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\r\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\r\n\r\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\r\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\r\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\r\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\r\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\r\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\r\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\r\nimport { setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { bvhcast } from './cast/bvhcast.js';\r\n\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst tempBox = /* @__PURE__ */ new Box3();\r\nexport const DEFAULT_OPTIONS = {\r\n\tstrategy: CENTER,\r\n\tmaxDepth: 40,\r\n\tmaxLeafTris: 10,\r\n\tuseSharedArrayBuffer: false,\r\n\tsetBoundingBox: true,\r\n\tonProgress: null,\r\n\tindirect: false,\r\n\tverbose: true,\r\n};\r\n\r\nexport class MeshBVH {\r\n\r\n\tstatic serialize( bvh, options = {} ) {\r\n\r\n\t\toptions = {\r\n\t\t\tcloneBuffers: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst geometry = bvh.geometry;\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indirectBuffer = bvh._indirectBuffer;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tlet result;\r\n\t\tif ( options.cloneBuffers ) {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData.map( root => root.slice() ),\r\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\r\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData,\r\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\r\n\t\t\t\tindirectBuffer: indirectBuffer,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, options = {} ) {\r\n\r\n\t\toptions = {\r\n\t\t\tsetIndex: true,\r\n\t\t\tindirect: Boolean( data.indirectBuffer ),\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst { index, roots, indirectBuffer } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\t\tbvh._indirectBuffer = indirectBuffer || null;\r\n\r\n\t\tif ( options.setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tget indirect() {\r\n\r\n\t\treturn ! ! this._indirectBuffer;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\t...DEFAULT_OPTIONS,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false,\r\n\r\n\t\t}, options );\r\n\r\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\t\tthis._roots = null;\r\n\t\tthis._indirectBuffer = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tbuildPackedTree( this, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null ) {\r\n\r\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\r\n\t\treturn refitFunc( this, nodeIndices );\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// TODO: use node functions here\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst intersects = [];\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst startCount = intersects.length;\r\n\r\n\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\r\n\r\n\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\r\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\t\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\r\n\r\n\t\tlet result = false;\r\n\t\tconst roots = this._roots;\r\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( callbacks ) {\r\n\r\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\r\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\t// wrap the intersectsRange function\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// run shapecast\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst root = roots[ i ];\r\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\r\n\r\n\t\tlet {\r\n\t\t\tintersectsRanges,\r\n\t\t\tintersectsTriangles,\r\n\t\t} = callbacks;\r\n\r\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\r\n\t\tconst indexAttr1 = this.geometry.index;\r\n\t\tconst positionAttr1 = this.geometry.attributes.position;\r\n\t\tconst assignTriangle1 = this.indirect ?\r\n\t\t\ti1 => {\r\n\r\n\r\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\r\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\r\n\r\n\t\t\t} :\r\n\t\t\ti1 => {\r\n\r\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\r\n\r\n\t\t\t};\r\n\r\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\r\n\t\tconst indexAttr2 = otherBvh.geometry.index;\r\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\r\n\t\tconst assignTriangle2 = otherBvh.indirect ?\r\n\t\t\ti2 => {\r\n\r\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\r\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\r\n\r\n\t\t\t} :\r\n\t\t\ti2 => {\r\n\r\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\r\n\r\n\t\t\t};\r\n\r\n\t\t// generate triangle callback if needed\r\n\t\tif ( intersectsTriangles ) {\r\n\r\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\r\n\r\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\tassignTriangle2( i2 );\r\n\r\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\r\n\r\n\t\t\t\t\t\tassignTriangle1( i1 );\r\n\r\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( intersectsRanges ) {\r\n\r\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\r\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\r\n\r\n\t}\r\n\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\r\n\t\treturn closestPointToGeometryFunc(\r\n\t\t\tthis,\r\n\t\t\totherGeometry,\r\n\t\t\tgeometryToBvh,\r\n\t\t\ttarget1,\r\n\t\t\ttarget2,\r\n\t\t\tminThreshold,\r\n\t\t\tmaxThreshold,\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\treturn closestPointToPoint(\r\n\t\t\tthis,\r\n\t\t\tpoint,\r\n\t\t\ttarget,\r\n\t\t\tminThreshold,\r\n\t\t\tmaxThreshold,\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n", "import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { MeshBVH } from '../core/MeshBVH.js';\r\n\r\nconst boundingBox = /* @__PURE__ */ new Box3();\r\nclass MeshBVHRootHelper extends Object3D {\r\n\r\n\tget isMesh() {\r\n\r\n\t\treturn ! this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLineSegments() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLine() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.material = material;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.name = 'MeshBVHRootHelper';\r\n\t\tthis.depth = depth;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.bvh = bvh;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._group = group;\r\n\r\n\t}\r\n\r\n\traycast() {}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst boundsTree = this.bvh;\r\n\t\tconst group = this._group;\r\n\t\tgeometry.dispose();\r\n\t\tthis.visible = false;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\t// count the number of bounds required\r\n\t\t\tconst targetDepth = this.depth - 1;\r\n\t\t\tconst displayParents = this.displayParents;\r\n\t\t\tlet boundsCount = 0;\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\r\n\r\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else if ( displayParents ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\t// fill in the position buffer with the bounds corners\r\n\t\t\tlet posIndex = 0;\r\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\r\n\r\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\r\n\t\t\t\tif ( terminate || displayParents ) {\r\n\r\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\r\n\r\n\t\t\t\t\tconst { min, max } = boundingBox;\r\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\r\n\r\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\r\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\r\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\r\n\r\n\t\t\t\t\t\t\t\tposIndex += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn terminate;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\tlet indexArray;\r\n\t\t\tlet indices;\r\n\t\t\tif ( this.displayEdges ) {\r\n\r\n\t\t\t\t// fill in the index buffer to point to the corner points\r\n\t\t\t\tindices = new Uint8Array( [\r\n\t\t\t\t\t// x axis\r\n\t\t\t\t\t0, 4,\r\n\t\t\t\t\t1, 5,\r\n\t\t\t\t\t2, 6,\r\n\t\t\t\t\t3, 7,\r\n\r\n\t\t\t\t\t// y axis\r\n\t\t\t\t\t0, 2,\r\n\t\t\t\t\t1, 3,\r\n\t\t\t\t\t4, 6,\r\n\t\t\t\t\t5, 7,\r\n\r\n\t\t\t\t\t// z axis\r\n\t\t\t\t\t0, 1,\r\n\t\t\t\t\t2, 3,\r\n\t\t\t\t\t4, 5,\r\n\t\t\t\t\t6, 7,\r\n\t\t\t\t] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindices = new Uint8Array( [\r\n\r\n\t\t\t\t\t// X-, X+\r\n\t\t\t\t\t0, 1, 2,\r\n\t\t\t\t\t2, 1, 3,\r\n\r\n\t\t\t\t\t4, 6, 5,\r\n\t\t\t\t\t6, 7, 5,\r\n\r\n\t\t\t\t\t// Y-, Y+\r\n\t\t\t\t\t1, 4, 5,\r\n\t\t\t\t\t0, 4, 1,\r\n\r\n\t\t\t\t\t2, 3, 6,\r\n\t\t\t\t\t3, 7, 6,\r\n\r\n\t\t\t\t\t// Z-, Z+\r\n\t\t\t\t\t0, 2, 4,\r\n\t\t\t\t\t2, 6, 4,\r\n\r\n\t\t\t\t\t1, 5, 3,\r\n\t\t\t\t\t3, 5, 7,\r\n\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positionArray.length > 65535 ) {\r\n\r\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst indexLength = indices.length;\r\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\r\n\r\n\t\t\t\tconst posOffset = i * 8;\r\n\t\t\t\tconst indexOffset = i * indexLength;\r\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\r\n\r\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the geometry\r\n\t\t\tgeometry.setIndex(\r\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\r\n\t\t\t);\r\n\t\t\tgeometry.setAttribute(\r\n\t\t\t\t'position',\r\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\r\n\t\t\t);\r\n\t\t\tthis.visible = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHHelper extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.edgeMaterial.color;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this.edgeMaterial.opacity;\r\n\r\n\t}\r\n\r\n\tset opacity( v ) {\r\n\r\n\t\tthis.edgeMaterial.opacity = v;\r\n\t\tthis.meshMaterial.opacity = v;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\r\n\r\n\t\t// handle bvh, depth signature\r\n\t\tif ( mesh instanceof MeshBVH ) {\r\n\r\n\t\t\tdepth = bvh || 10;\r\n\t\t\tbvh = mesh;\r\n\t\t\tmesh = null;\r\n\r\n\t\t}\r\n\r\n\t\t// handle mesh, depth signature\r\n\t\tif ( typeof bvh === 'number' ) {\r\n\r\n\t\t\tdepth = bvh;\r\n\t\t\tbvh = null;\r\n\r\n\t\t}\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.name = 'MeshBVHHelper';\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.bvh = bvh;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._roots = [];\r\n\r\n\t\tconst edgeMaterial = new LineBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tconst meshMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tmeshMaterial.color = edgeMaterial.color;\r\n\r\n\t\tthis.edgeMaterial = edgeMaterial;\r\n\t\tthis.meshMaterial = meshMaterial;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.bvh || this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tconst root = this._roots.pop();\r\n\t\t\troot.geometry.dispose();\r\n\t\t\tthis.remove( root );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst root = this._roots[ i ];\r\n\t\t\troot.bvh = bvh;\r\n\t\t\troot.depth = depth;\r\n\t\t\troot.displayParents = displayParents;\r\n\t\t\troot.displayEdges = displayEdges;\r\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\r\n\t\t\troot.update();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tconst mesh = this.mesh;\r\n\t\tconst parent = this.parent;\r\n\r\n\t\tif ( mesh !== null ) {\r\n\r\n\t\t\tmesh.updateWorldMatrix( true, false );\r\n\r\n\t\t\tif ( parent ) {\r\n\r\n\t\t\t\tthis.matrix\r\n\t\t\t\t\t.copy( parent.matrixWorld )\r\n\t\t\t\t\t.invert()\r\n\t\t\t\t\t.multiply( mesh.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrix\r\n\t\t\t\t\t.copy( mesh.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrix.decompose(\r\n\t\t\t\tthis.position,\r\n\t\t\t\tthis.quaternion,\r\n\t\t\t\tthis.scale,\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\t\tthis.bvh = source.bvh;\r\n\t\tthis.opacity = source.opacity;\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.edgeMaterial.dispose();\r\n\t\tthis.meshMaterial.dispose();\r\n\r\n\t\tconst children = this.children;\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].geometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class MeshBVHVisualizer extends MeshBVHHelper {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { MeshBVHHelper };\r\n", "import { Box3, Vector3 } from 'three';\r\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\r\n\r\nconst _box1 = /* @__PURE__ */ new Box3();\r\nconst _box2 = /* @__PURE__ */ new Box3();\r\nconst _vec = /* @__PURE__ */ new Vector3();\r\n\r\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\r\nfunction getPrimitiveSize( el ) {\r\n\r\n\tswitch ( typeof el ) {\r\n\r\n\t\tcase 'number':\r\n\t\t\treturn 8;\r\n\t\tcase 'string':\r\n\t\t\treturn el.length * 2;\r\n\t\tcase 'boolean':\r\n\t\t\treturn 4;\r\n\t\tdefault:\r\n\t\t\treturn 0;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction isTypedArray( arr ) {\r\n\r\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\r\n\treturn regex.test( arr.constructor.name );\r\n\r\n}\r\n\r\nfunction getRootExtremes( bvh, group ) {\r\n\r\n\tconst result = {\r\n\t\tnodeCount: 0,\r\n\t\tleafNodeCount: 0,\r\n\r\n\t\tdepth: {\r\n\t\t\tmin: Infinity, max: - Infinity\r\n\t\t},\r\n\t\ttris: {\r\n\t\t\tmin: Infinity, max: - Infinity\r\n\t\t},\r\n\t\tsplits: [ 0, 0, 0 ],\r\n\t\tsurfaceAreaScore: 0,\r\n\t};\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\r\n\r\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\r\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\r\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\r\n\r\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\r\n\r\n\t\tresult.nodeCount ++;\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tresult.leafNodeCount ++;\r\n\r\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\r\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\r\n\r\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\r\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\r\n\r\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult.splits[ offsetOrSplit ] ++;\r\n\r\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\r\n\r\n\t\t}\r\n\r\n\t}, group );\r\n\r\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\r\n\tif ( result.tris.min === Infinity ) {\r\n\r\n\t\tresult.tris.min = 0;\r\n\t\tresult.tris.max = 0;\r\n\r\n\t}\r\n\r\n\tif ( result.depth.min === Infinity ) {\r\n\r\n\t\tresult.depth.min = 0;\r\n\t\tresult.depth.max = 0;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction getBVHExtremes( bvh ) {\r\n\r\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\r\n\r\n}\r\n\r\nfunction estimateMemoryInBytes( obj ) {\r\n\r\n\tconst traversed = new Set();\r\n\tconst stack = [ obj ];\r\n\tlet bytes = 0;\r\n\r\n\twhile ( stack.length ) {\r\n\r\n\t\tconst curr = stack.pop();\r\n\t\tif ( traversed.has( curr ) ) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\ttraversed.add( curr );\r\n\r\n\t\tfor ( let key in curr ) {\r\n\r\n\t\t\tif ( ! Object.hasOwn( curr, key ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbytes += getPrimitiveSize( key );\r\n\r\n\t\t\tconst value = curr[ key ];\r\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\r\n\r\n\t\t\t\tif ( isTypedArray( value ) ) {\r\n\r\n\t\t\t\t\tbytes += value.byteLength;\r\n\r\n\t\t\t\t} else if ( isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer ) {\r\n\r\n\t\t\t\t\tbytes += value.byteLength;\r\n\r\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\r\n\r\n\t\t\t\t\tbytes += value.byteLength;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstack.push( value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbytes += getPrimitiveSize( value );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn bytes;\r\n\r\n}\r\n\r\nfunction validateBounds( bvh ) {\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tconst depthStack = [];\r\n\tconst index = geometry.index;\r\n\tconst position = geometry.getAttribute( 'position' );\r\n\tlet passes = true;\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\tconst info = {\r\n\t\t\tdepth,\r\n\t\t\tisLeaf,\r\n\t\t\tboundingData,\r\n\t\t\toffset,\r\n\t\t\tcount,\r\n\t\t};\r\n\t\tdepthStack[ depth ] = info;\r\n\r\n\t\tarrayToBox( 0, boundingData, _box1 );\r\n\t\tconst parent = depthStack[ depth - 1 ];\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\t// check triangles\r\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst triIndex = bvh.resolveTriangleIndex( i );\r\n\t\t\t\tlet i0 = 3 * triIndex;\r\n\t\t\t\tlet i1 = 3 * triIndex + 1;\r\n\t\t\t\tlet i2 = 3 * triIndex + 2;\r\n\r\n\t\t\t\tif ( index ) {\r\n\r\n\t\t\t\t\ti0 = index.getX( i0 );\r\n\t\t\t\t\ti1 = index.getX( i1 );\r\n\t\t\t\t\ti2 = index.getX( i2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet isContained;\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\r\n\t\t\t\tisContained = _box1.containsPoint( _vec );\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\r\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\r\n\r\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\r\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\r\n\r\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\r\n\t\t\t\tpasses = passes && isContained;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( parent ) {\r\n\r\n\t\t\t// check if my bounds fit in my parents\r\n\t\t\tarrayToBox( 0, boundingData, _box2 );\r\n\r\n\t\t\tconst isContained = _box2.containsBox( _box1 );\r\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\r\n\t\t\tpasses = passes && isContained;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn passes;\r\n\r\n}\r\n\r\n// Returns a simple, human readable object that represents the BVH.\r\nfunction getJSONStructure( bvh ) {\r\n\r\n\tconst depthStack = [];\r\n\r\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\r\n\r\n\t\tconst info = {\r\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\r\n\t\t};\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tinfo.count = count;\r\n\t\t\tinfo.offset = offset;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinfo.left = null;\r\n\t\t\tinfo.right = null;\r\n\r\n\t\t}\r\n\r\n\t\tdepthStack[ depth ] = info;\r\n\r\n\t\t// traversal hits the left then right node\r\n\t\tconst parent = depthStack[ depth - 1 ];\r\n\t\tif ( parent ) {\r\n\r\n\t\t\tif ( parent.left === null ) {\r\n\r\n\t\t\t\tparent.left = info;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tparent.right = info;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn depthStack[ 0 ];\r\n\r\n}\r\n\r\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\r\n", "import { Ray, Matrix4, Mesh, Vector3 } from 'three';\r\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\r\nimport { MeshBVH } from '../core/MeshBVH.js';\r\n\r\nconst ray = /* @__PURE__ */ new Ray();\r\nconst direction = /* @__PURE__ */ new Vector3();\r\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\r\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\r\nconst _worldScale = /* @__PURE__ */ new Vector3();\r\n\r\nexport function acceleratedRaycast( raycaster, intersects ) {\r\n\r\n\tif ( this.geometry.boundsTree ) {\r\n\r\n\t\tif ( this.material === undefined ) return;\r\n\r\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\r\n\r\n\t\textractMatrixScale( this.matrixWorld, _worldScale );\r\n\t\tdirection.copy( ray.direction ).multiply( _worldScale );\r\n\r\n\t\tconst scaleFactor = direction.length();\r\n\t\tconst near = raycaster.near / scaleFactor;\r\n\t\tconst far = raycaster.far / scaleFactor;\r\n\r\n\t\tconst bvh = this.geometry.boundsTree;\r\n\t\tif ( raycaster.firstHitOnly === true ) {\r\n\r\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\r\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\r\n\t\t\t\tif ( hit ) {\r\n\r\n\t\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function computeBoundsTree( options ) {\r\n\r\n\tthis.boundsTree = new MeshBVH( this, options );\r\n\treturn this.boundsTree;\r\n\r\n}\r\n\r\nexport function disposeBoundsTree() {\r\n\r\n\tthis.boundsTree = null;\r\n\r\n}\r\n\r\n// https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js#L732\r\n// extracting the scale directly is ~3x faster than using \"decompose\"\r\nfunction extractMatrixScale( matrix, target ) {\r\n\r\n\tconst te = matrix.elements;\r\n\tconst sx = target.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\tconst sy = target.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\tconst sz = target.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\treturn target.set( sx, sy, sz );\r\n\r\n}\r\n", "import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\r\n\r\nconst _positionVector = /*@__PURE__*/ new Vector3();\r\nconst _normalVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\r\n\r\nconst _morphVector = /*@__PURE__*/ new Vector3();\r\nconst _temp = /*@__PURE__*/ new Vector3();\r\n\r\nconst _skinIndex = /*@__PURE__*/ new Vector4();\r\nconst _skinWeight = /*@__PURE__*/ new Vector4();\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\r\n\r\n// Confirms that the two provided attributes are compatible\r\nfunction validateAttributes( attr1, attr2 ) {\r\n\r\n\tif ( ! attr1 && ! attr2 ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tconst sameCount = attr1.count === attr2.count;\r\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\r\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\r\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\r\n\r\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Clones the given attribute with a new compatible buffer attribute but no data\r\nfunction createAttributeClone( attr, countOverride = null ) {\r\n\r\n\tconst cons = attr.array.constructor;\r\n\tconst normalized = attr.normalized;\r\n\tconst itemSize = attr.itemSize;\r\n\tconst count = countOverride === null ? attr.count : countOverride;\r\n\r\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\r\n\r\n}\r\n\r\n// target offset is the number of elements in the target buffer stride to skip before copying the\r\n// attributes contents in to.\r\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\r\n\r\n\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\r\n\r\n\t\t\tconst io = i + targetOffset;\r\n\t\t\ttarget.setX( io, attr.getX( i ) );\r\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\r\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\r\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst array = target.array;\r\n\t\tconst cons = array.constructor;\r\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\r\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\r\n\t\ttemp.set( attr.array );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\r\nfunction addScaledMatrix( target, matrix, scale ) {\r\n\r\n\tconst targetArray = target.elements;\r\n\tconst matrixArray = matrix.elements;\r\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\r\n\r\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// A version of \"SkinnedMesh.boneTransform\" for normals\r\nfunction boneNormalTransform( mesh, index, target ) {\r\n\r\n\tconst skeleton = mesh.skeleton;\r\n\tconst geometry = mesh.geometry;\r\n\tconst bones = skeleton.bones;\r\n\tconst boneInverses = skeleton.boneInverses;\r\n\r\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\r\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\r\n\r\n\t_matrix.elements.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\tconst weight = _skinWeight.getComponent( i );\r\n\r\n\t\tif ( weight !== 0 ) {\r\n\r\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\r\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\r\n\r\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\r\n\ttarget.transformDirection( _matrix );\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\n// Applies the morph target data to the target vector\r\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\r\n\r\n\t_morphVector.set( 0, 0, 0 );\r\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\r\n\r\n\t\tconst influence = morphInfluences[ j ];\r\n\t\tconst morphAttribute = morphData[ j ];\r\n\r\n\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\r\n\r\n\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp, influence );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttarget.add( _morphVector );\r\n\r\n}\r\n\r\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\r\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\r\n\r\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\tconst attributes = {};\r\n\r\n\tlet offset = 0;\r\n\r\n\ttargetGeometry.clearGroups();\r\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\tconst geometry = geometries[ i ];\r\n\t\tlet attributesCount = 0;\r\n\r\n\t\t// ensure that all geometries are indexed, or none\r\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t}\r\n\r\n\t\t// gather attributes, exit early if they're different\r\n\t\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes[ name ] === undefined ) {\r\n\r\n\t\t\t\tattributes[ name ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\r\n\t\t\tattributesCount ++;\r\n\r\n\t\t}\r\n\r\n\t\t// ensure geometries have the same number of attributes\r\n\t\tif ( attributesCount !== attributesUsed.size ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( useGroups ) {\r\n\r\n\t\t\tlet count;\r\n\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\tcount = geometry.index.count;\r\n\r\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\r\n\r\n\t\t\t\tcount = geometry.attributes.position.count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.addGroup( offset, count, i );\r\n\t\t\toffset += count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge indices\r\n\tif ( isIndexed ) {\r\n\r\n\t\tlet forceUpdateIndex = false;\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\tlet indexCount = 0;\r\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tindexCount += geometries[ i ].index.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\r\n\t\t\tforceUpdateIndex = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateIndex || forceUpdateIndex ) {\r\n\r\n\t\t\tconst targetIndex = targetGeometry.index;\r\n\t\t\tlet targetOffset = 0;\r\n\t\t\tlet indexOffset = 0;\r\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\t\tconst geometry = geometries[ i ];\r\n\t\t\t\tconst index = geometry.index;\r\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\r\n\r\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\r\n\t\t\t\t\t\ttargetOffset ++;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tindexOffset += geometry.attributes.position.count;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge attributes\r\n\tfor ( const name in attributes ) {\r\n\r\n\t\tconst attrList = attributes[ name ];\r\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\r\n\r\n\t\t\tlet count = 0;\r\n\t\t\tfor ( const key in attrList ) {\r\n\r\n\t\t\t\tcount += attrList[ key ].count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\r\n\t\tlet offset = 0;\r\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst attr = attrList[ i ];\r\n\t\t\tif ( skipAttributes[ i ] !== true ) {\r\n\r\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset += attr.count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn targetGeometry;\r\n\r\n}\r\n\r\nfunction checkTypedArrayEquality( a, b ) {\r\n\r\n\tif ( a === null || b === null ) {\r\n\r\n\t\treturn a === b;\r\n\r\n\t}\r\n\r\n\tif ( a.length !== b.length ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\r\n\r\n\t\tif ( a[ i ] !== b[ i ] ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction invertGeometry( geometry ) {\r\n\r\n\tconst { index, attributes } = geometry;\r\n\tif ( index ) {\r\n\r\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\r\n\r\n\t\t\tconst v0 = index.getX( i );\r\n\t\t\tconst v2 = index.getX( i + 2 );\r\n\t\t\tindex.setX( i, v2 );\r\n\t\t\tindex.setX( i + 2, v0 );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\tconst attr = attributes[ key ];\r\n\t\t\tconst itemSize = attr.itemSize;\r\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\r\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\r\n\t\t\t\t\tattr.setComponent( i, j, v2 );\r\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n\r\n}\r\n\r\n// Checks whether the geometry changed between this and last evaluation\r\nclass GeometryDiff {\r\n\r\n\tconstructor( mesh ) {\r\n\r\n\t\tthis.matrixWorld = new Matrix4();\r\n\t\tthis.geometryHash = null;\r\n\t\tthis.boneMatrices = null;\r\n\t\tthis.primitiveCount = - 1;\r\n\t\tthis.mesh = mesh;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst mesh = this.mesh;\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst skeleton = mesh.skeleton;\r\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\r\n\t\tthis.geometryHash = geometry.attributes.position.version;\r\n\t\tthis.primitiveCount = primitiveCount;\r\n\r\n\t\tif ( skeleton ) {\r\n\r\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\r\n\t\t\tif ( ! skeleton.boneTexture ) {\r\n\r\n\t\t\t\tskeleton.computeBoneTexture();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tskeleton.update();\r\n\r\n\t\t\t// copy data if possible otherwise clone it\r\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\r\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\r\n\r\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boneMatrices = null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdidChange() {\r\n\r\n\t\tconst mesh = this.mesh;\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\t\tconst identical =\r\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\r\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\r\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\r\n\t\t\tthis.primitiveCount === primitiveCount;\r\n\r\n\t\treturn ! identical;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class StaticGeometryGenerator {\r\n\r\n\tconstructor( meshes ) {\r\n\r\n\t\tif ( ! Array.isArray( meshes ) ) {\r\n\r\n\t\t\tmeshes = [ meshes ];\r\n\r\n\t\t}\r\n\r\n\t\tconst finalMeshes = [];\r\n\t\tmeshes.forEach( object => {\r\n\r\n\t\t\tobject.traverseVisible( c => {\r\n\r\n\t\t\t\tif ( c.isMesh ) {\r\n\r\n\t\t\t\t\tfinalMeshes.push( c );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.meshes = finalMeshes;\r\n\t\tthis.useGroups = true;\r\n\t\tthis.applyWorldTransforms = true;\r\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\r\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\r\n\t\tthis._diffMap = new WeakMap();\r\n\r\n\t}\r\n\r\n\tgetMaterials() {\r\n\r\n\t\tconst materials = [];\r\n\t\tthis.meshes.forEach( mesh => {\r\n\r\n\t\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\t\tmaterials.push( ...mesh.material );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterials.push( mesh.material );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\t\treturn materials;\r\n\r\n\t}\r\n\r\n\tgenerate( targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\r\n\t\tlet skipAttributes = [];\r\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\r\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst mesh = meshes[ i ];\r\n\t\t\tconst geom = _intermediateGeometry[ i ];\r\n\t\t\tconst diff = _diffMap.get( mesh );\r\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\r\n\r\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\r\n\t\t\t\tskipAttributes.push( false );\r\n\r\n\t\t\t\tif ( ! diff ) {\r\n\r\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tdiff.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tskipAttributes.push( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( _intermediateGeometry.length === 0 ) {\r\n\r\n\t\t\t// if there are no geometries then just create a fake empty geometry to provide\r\n\t\t\ttargetGeometry.setIndex( null );\r\n\r\n\t\t\t// remove all geometry\r\n\t\t\tconst attrs = targetGeometry.attributes;\r\n\t\t\tfor ( const key in attrs ) {\r\n\r\n\t\t\t\ttargetGeometry.deleteAttribute( key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// create dummy attributes\r\n\t\t\tfor ( const key in this.attributes ) {\r\n\r\n\t\t\t\ttargetGeometry.setAttribute( this.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( const key in targetGeometry.attributes ) {\r\n\r\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\treturn targetGeometry;\r\n\r\n\t}\r\n\r\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\r\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\r\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\r\n\t\tconst attributes = geometry.attributes;\r\n\t\tconst targetAttributes = targetGeometry.attributes;\r\n\r\n\t\t// initialize the attributes if they don't exist\r\n\t\tif ( ! targetGeometry.index && geometry.index ) {\r\n\r\n\t\t\ttargetGeometry.index = geometry.index.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! targetAttributes.position ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\r\n\r\n\t\t}\r\n\r\n\t\t// ensure the attributes are consistent\r\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\r\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\r\n\r\n\t\tif ( includeNormal ) {\r\n\r\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( includeTangent ) {\r\n\r\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\r\n\r\n\t\t}\r\n\r\n\t\t// generate transformed vertex attribute data\r\n\t\tconst position = attributes.position;\r\n\t\tconst normal = includeNormal ? attributes.normal : null;\r\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\r\n\t\tconst morphPosition = geometry.morphAttributes.position;\r\n\t\tconst morphNormal = geometry.morphAttributes.normal;\r\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\r\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\r\n\t\tconst normalMatrix = new Matrix3();\r\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t\t// copy the index\r\n\t\tif ( geometry.index ) {\r\n\r\n\t\t\ttargetGeometry.index.array.set( geometry.index.array );\r\n\r\n\t\t}\r\n\r\n\t\t// copy and apply other attributes\r\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\r\n\r\n\t\t\t_positionVector.fromBufferAttribute( position, i );\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\r\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// apply morph target transform\r\n\t\t\tif ( morphInfluences ) {\r\n\r\n\t\t\t\tif ( morphPosition ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( morphNormal ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( morphTangent ) {\r\n\r\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// apply bone transform\r\n\t\t\tif ( mesh.isSkinnedMesh ) {\r\n\r\n\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\r\n\t\t\t\tif ( normal ) {\r\n\r\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the vectors of the attributes\r\n\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\r\n\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// copy other attributes over\r\n\t\tfor ( const i in this.attributes ) {\r\n\r\n\t\t\tconst key = this.attributes[ i ];\r\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! targetAttributes[ key ] ) {\r\n\r\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\r\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( mesh.matrixWorld.determinant() < 0 ) {\r\n\r\n\t\t\tinvertGeometry( targetGeometry );\r\n\r\n\t\t}\r\n\r\n\t\treturn targetGeometry;\r\n\r\n\t}\r\n\r\n}\r\n", "export * from './glsl/common_functions.glsl.js';\r\nexport * from './glsl/bvh_distance_functions.glsl.js';\r\nexport * from './glsl/bvh_ray_functions.glsl.js';\r\nexport * from './glsl/bvh_struct_definitions.glsl.js';\r\n", "export const common_functions = /* glsl */`\r\n\r\n// A stack of uint32 indices can can store the indices for\r\n// a perfectly balanced tree with a depth up to 31. Lower stack\r\n// depth gets higher performance.\r\n//\r\n// However not all trees are balanced. Best value to set this to\r\n// is the trees max depth.\r\n#ifndef BVH_STACK_DEPTH\r\n#define BVH_STACK_DEPTH 60\r\n#endif\r\n\r\n#ifndef INFINITY\r\n#define INFINITY 1e20\r\n#endif\r\n\r\n// Utilities\r\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nvec4 texelFetch1D( sampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\r\n\r\n\treturn\r\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\r\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\r\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\r\n\r\n}\r\n\r\nvoid ndcToCameraRay(\r\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\r\n\tout vec3 rayOrigin, out vec3 rayDirection\r\n) {\r\n\r\n\t// get camera look direction and near plane for camera clipping\r\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\r\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\r\n\tfloat near = abs( nearVector.z / nearVector.w );\r\n\r\n\t// get the camera direction and position from camera matrices\r\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\r\n\tdirection /= direction.w;\r\n\tdirection = cameraWorld * direction - origin;\r\n\r\n\t// slide the origin along the ray until it sits at the near clip plane position\r\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\r\n\r\n\trayOrigin = origin.xyz;\r\n\trayDirection = direction.xyz;\r\n\r\n}\r\n`;\r\n", "// Distance to Point\r\nexport const bvh_distance_functions = /* glsl */`\r\n\r\nfloat dot2( vec3 v ) {\r\n\r\n\treturn dot( v, v );\r\n\r\n}\r\n\r\n// https://www.shadertoy.com/view/ttfGWl\r\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\r\n\r\n    vec3 v10 = v1 - v0;\r\n    vec3 v21 = v2 - v1;\r\n    vec3 v02 = v0 - v2;\r\n\r\n\tvec3 p0 = p - v0;\r\n\tvec3 p1 = p - v1;\r\n\tvec3 p2 = p - v2;\r\n\r\n    vec3 nor = cross( v10, v02 );\r\n\r\n    // method 2, in barycentric space\r\n    vec3  q = cross( nor, p0 );\r\n    float d = 1.0 / dot2( nor );\r\n    float u = d * dot( q, v02 );\r\n    float v = d * dot( q, v10 );\r\n    float w = 1.0 - u - v;\r\n\r\n\tif( u < 0.0 ) {\r\n\r\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\r\n\t\tu = 0.0;\r\n\t\tv = 1.0 - w;\r\n\r\n\t} else if( v < 0.0 ) {\r\n\r\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\r\n\t\tv = 0.0;\r\n\t\tw = 1.0 - u;\r\n\r\n\t} else if( w < 0.0 ) {\r\n\r\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\r\n\t\tw = 0.0;\r\n\t\tu = 1.0-v;\r\n\r\n\t}\r\n\r\n\tbarycoord = vec3( u, v, w );\r\n    return u * v1 + v * v2 + w * v0;\r\n\r\n}\r\n\r\nfloat distanceToTriangles(\r\n\t// geometry info and triangle range\r\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\r\n\r\n\t// point and cut off range\r\n\tvec3 point, float closestDistanceSquared,\r\n\r\n\t// outputs\r\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\r\n) {\r\n\r\n\tbool found = false;\r\n\tvec3 localBarycoord;\r\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\r\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\r\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\r\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\r\n\r\n\t\t// get the closest point and barycoord\r\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\r\n\t\tvec3 delta = point - closestPoint;\r\n\t\tfloat sqDist = dot2( delta );\r\n\t\tif ( sqDist < closestDistanceSquared ) {\r\n\r\n\t\t\t// set the output results\r\n\t\t\tclosestDistanceSquared = sqDist;\r\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\r\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\r\n\t\t\tbarycoord = localBarycoord;\r\n\t\t\toutPoint = closestPoint;\r\n\t\t\tside = sign( dot( faceNormal, delta ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn closestDistanceSquared;\r\n\r\n}\r\n\r\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\r\n\r\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\r\n\tvec3 delta = point - clampedPoint;\r\n\treturn dot( delta, delta );\r\n\r\n}\r\n\r\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\r\n\r\n\tuint cni2 = currNodeIndex * 2u;\r\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\r\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\r\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\r\n\r\n}\r\n\r\n// use a macro to hide the fact that we need to expand the struct into separate fields\r\n#define\\\r\n\tbvhClosestPointToPoint(\\\r\n\t\tbvh,\\\r\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\r\n\t)\\\r\n\t_bvhClosestPointToPoint(\\\r\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\r\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\r\n\t)\r\n\r\nfloat _bvhClosestPointToPoint(\r\n\t// bvh info\r\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\r\n\r\n\t// point to check\r\n\tvec3 point,\r\n\r\n\t// output variables\r\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\r\n\tinout float side, inout vec3 outPoint\r\n ) {\r\n\r\n\t// stack needs to be twice as long as the deepest tree we expect because\r\n\t// we push both the left and right child onto the stack every traversal\r\n\tint ptr = 0;\r\n\tuint stack[ BVH_STACK_DEPTH ];\r\n\tstack[ 0 ] = 0u;\r\n\r\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\r\n\tbool found = false;\r\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\r\n\r\n\t\tuint currNodeIndex = stack[ ptr ];\r\n\t\tptr --;\r\n\r\n\t\t// check if we intersect the current bounds\r\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\r\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\r\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\r\n\t\t\tuint offset = boundsInfo.y;\r\n\t\t\tclosestDistanceSquared = distanceToTriangles(\r\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\r\n\r\n\t\t\t\t// outputs\r\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\r\n\t\t\t);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuint leftIndex = currNodeIndex + 1u;\r\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\r\n\t\t\tuint rightIndex = boundsInfo.y;\r\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\r\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\r\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\r\n\r\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\r\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\r\n\t\t\t// traversed first\r\n\t\t\tptr ++;\r\n\t\t\tstack[ ptr ] = c2;\r\n\t\t\tptr ++;\r\n\t\t\tstack[ ptr ] = c1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn sqrt( closestDistanceSquared );\r\n\r\n}\r\n`;\r\n", "export const bvh_ray_functions = /* glsl */`\r\n\r\n#ifndef TRI_INTERSECT_EPSILON\r\n#define TRI_INTERSECT_EPSILON 1e-5\r\n#endif\r\n\r\n// Raycasting\r\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\r\n\r\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\r\n\t// https://tavianator.com/2011/ray_box.html\r\n\tvec3 invDir = 1.0 / rayDirection;\r\n\r\n\t// find intersection distances for each plane\r\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\r\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\r\n\r\n\t// get the min and max distances from each intersection\r\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\r\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\r\n\r\n\t// get the furthest hit distance\r\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\r\n\tfloat t0 = max( t.x, t.y );\r\n\r\n\t// get the minimum hit distance\r\n\tt = min( tMaxHit.xx, tMaxHit.yz );\r\n\tfloat t1 = min( t.x, t.y );\r\n\r\n\t// set distance to 0.0 if the ray starts inside the box\r\n\tdist = max( t0, 0.0 );\r\n\r\n\treturn t1 >= dist;\r\n\r\n}\r\n\r\nbool intersectsTriangle(\r\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\r\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\r\n) {\r\n\r\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\r\n\tvec3 edge1 = b - a;\r\n\tvec3 edge2 = c - a;\r\n\tnorm = cross( edge1, edge2 );\r\n\r\n\tfloat det = - dot( rayDirection, norm );\r\n\tfloat invdet = 1.0 / det;\r\n\r\n\tvec3 AO = rayOrigin - a;\r\n\tvec3 DAO = cross( AO, rayDirection );\r\n\r\n\tvec4 uvt;\r\n\tuvt.x = dot( edge2, DAO ) * invdet;\r\n\tuvt.y = - dot( edge1, DAO ) * invdet;\r\n\tuvt.z = dot( AO, norm ) * invdet;\r\n\tuvt.w = 1.0 - uvt.x - uvt.y;\r\n\r\n\t// set the hit information\r\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\r\n\tdist = uvt.z;\r\n\tside = sign( det );\r\n\tnorm = side * normalize( norm );\r\n\r\n\t// add an epsilon to avoid misses between triangles\r\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\r\n\r\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\r\n\r\n}\r\n\r\nbool intersectTriangles(\r\n\t// geometry info and triangle range\r\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\r\n\r\n\t// ray\r\n\tvec3 rayOrigin, vec3 rayDirection,\r\n\r\n\t// outputs\r\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\r\n\tinout float side, inout float dist\r\n) {\r\n\r\n\tbool found = false;\r\n\tvec3 localBarycoord, localNormal;\r\n\tfloat localDist, localSide;\r\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\r\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\r\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\r\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\r\n\r\n\t\tif (\r\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\r\n\t\t\t&& localDist < minDistance\r\n\t\t) {\r\n\r\n\t\t\tfound = true;\r\n\t\t\tminDistance = localDist;\r\n\r\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\r\n\t\t\tfaceNormal = localNormal;\r\n\r\n\t\t\tside = localSide;\r\n\t\t\tbarycoord = localBarycoord;\r\n\t\t\tdist = localDist;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn found;\r\n\r\n}\r\n\r\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\r\n\r\n\tuint cni2 = currNodeIndex * 2u;\r\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\r\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\r\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\r\n\r\n}\r\n\r\n// use a macro to hide the fact that we need to expand the struct into separate fields\r\n#define\\\r\n\tbvhIntersectFirstHit(\\\r\n\t\tbvh,\\\r\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\r\n\t)\\\r\n\t_bvhIntersectFirstHit(\\\r\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\r\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\r\n\t)\r\n\r\nbool _bvhIntersectFirstHit(\r\n\t// bvh info\r\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\r\n\r\n\t// ray\r\n\tvec3 rayOrigin, vec3 rayDirection,\r\n\r\n\t// output variables split into separate variables due to output precision\r\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\r\n\tinout float side, inout float dist\r\n) {\r\n\r\n\t// stack needs to be twice as long as the deepest tree we expect because\r\n\t// we push both the left and right child onto the stack every traversal\r\n\tint ptr = 0;\r\n\tuint stack[ BVH_STACK_DEPTH ];\r\n\tstack[ 0 ] = 0u;\r\n\r\n\tfloat triangleDistance = INFINITY;\r\n\tbool found = false;\r\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\r\n\r\n\t\tuint currNodeIndex = stack[ ptr ];\r\n\t\tptr --;\r\n\r\n\t\t// check if we intersect the current bounds\r\n\t\tfloat boundsHitDistance;\r\n\t\tif (\r\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\r\n\t\t\t|| boundsHitDistance > triangleDistance\r\n\t\t) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\r\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\r\n\t\t\tuint offset = boundsInfo.y;\r\n\r\n\t\t\tfound = intersectTriangles(\r\n\t\t\t\tbvh_position, bvh_index, offset, count,\r\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\r\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\r\n\t\t\t) || found;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tuint leftIndex = currNodeIndex + 1u;\r\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\r\n\t\t\tuint rightIndex = boundsInfo.y;\r\n\r\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\r\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\r\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\r\n\r\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\r\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\r\n\t\t\t// traversed first\r\n\t\t\tptr ++;\r\n\t\t\tstack[ ptr ] = c2;\r\n\r\n\t\t\tptr ++;\r\n\t\t\tstack[ ptr ] = c1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn found;\r\n\r\n}\r\n`;\r\n", "// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\r\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\r\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\r\nexport const bvh_struct_definitions = /* glsl */`\r\nstruct BVH {\r\n\r\n\tusampler2D index;\r\n\tsampler2D position;\r\n\r\n\tsampler2D bvhBounds;\r\n\tusampler2D bvhContents;\r\n\r\n};\r\n`;\r\n", "export { MeshBVH } from './core/MeshBVH.js';\r\nexport { MeshBVHHelper } from './objects/MeshBVHHelper.js';\r\nexport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './core/Constants.js';\r\nexport { getBVHExtremes, estimateMemoryInBytes, getJSONStructure, validateBounds } from './debug/Debug.js';\r\nexport { acceleratedRaycast, computeBoundsTree, disposeBoundsTree } from './utils/ExtensionUtilities.js';\r\nexport { getTriangleHitPointInfo } from './utils/TriangleUtilities.js';\r\nexport * from './math/ExtendedTriangle.js';\r\nexport * from './math/OrientedBox.js';\r\nexport * from './gpu/MeshBVHUniformStruct.js';\r\nexport * from './gpu/VertexAttributeTexture.js';\r\nexport * from './utils/StaticGeometryGenerator.js';\r\nexport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\r\n\r\n// backwards compatibility\r\nimport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\r\nexport const shaderStructs = BVHShaderGLSL.bvh_struct_definitions;\r\nexport const shaderDistanceFunction = BVHShaderGLSL.bvh_distance_functions;\r\nexport const shaderIntersectFunction = `\r\n\t${ BVHShaderGLSL.common_functions }\r\n\t${ BVHShaderGLSL.bvh_ray_functions }\r\n`;\r\n", "const HASH_WIDTH = 1e-6;\r\nconst HASH_HALF_WIDTH = HASH_WIDTH * 0.5;\r\nconst HASH_MULTIPLIER = Math.pow( 10, - Math.log10( HASH_WIDTH ) );\r\nconst HASH_ADDITION = HASH_HALF_WIDTH * HASH_MULTIPLIER;\r\nexport function hashNumber( v ) {\r\n\r\n\treturn ~ ~ ( v * HASH_MULTIPLIER + HASH_ADDITION );\r\n\r\n}\r\n\r\nexport function hashVertex2( v ) {\r\n\r\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) }`;\r\n\r\n}\r\n\r\nexport function hashVertex3( v ) {\r\n\r\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) }`;\r\n\r\n}\r\n\r\nexport function hashVertex4( v ) {\r\n\r\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) },${ hashNumber( v.w ) }`;\r\n\r\n}\r\n\r\nexport function hashRay( r ) {\r\n\r\n\treturn `${ hashVertex3( r.origin ) }-${ hashVertex3( r.direction ) }`;\r\n\r\n}\r\n\r\nexport function toNormalizedRay( v0, v1, target ) {\r\n\r\n\t// get a normalized direction\r\n\ttarget\r\n\t\t.direction\r\n\t\t.subVectors( v1, v0 )\r\n\t\t.normalize();\r\n\r\n\t// project the origin onto the perpendicular plane that\r\n\t// passes through 0, 0, 0\r\n\tconst scalar = v0.dot( target.direction );\r\n\ttarget.\r\n\t\torigin\r\n\t\t.copy( v0 )\r\n\t\t.addScaledVector( target.direction, - scalar );\r\n\r\n\treturn target;\r\n\r\n}\r\n", "import { BufferAttribute } from 'three';\r\n\r\nexport function areSharedArrayBuffersSupported() {\r\n\r\n\treturn typeof SharedArrayBuffer !== 'undefined';\r\n\r\n}\r\n\r\nexport function convertToSharedArrayBuffer( array ) {\r\n\r\n\tif ( array.buffer instanceof SharedArrayBuffer ) {\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n\tconst cons = array.constructor;\r\n\tconst buffer = array.buffer;\r\n\tconst sharedBuffer = new SharedArrayBuffer( buffer.byteLength );\r\n\r\n\tconst uintArray = new Uint8Array( buffer );\r\n\tconst sharedUintArray = new Uint8Array( sharedBuffer );\r\n\tsharedUintArray.set( uintArray, 0 );\r\n\r\n\treturn new cons( sharedBuffer );\r\n\r\n}\r\n\r\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\r\n\r\n\tif ( vertexCount > 65535 ) {\r\n\r\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\r\n\r\n\t} else {\r\n\r\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function ensureIndex( geo, options ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function getVertexCount( geo ) {\r\n\r\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\r\n\r\n}\r\n\r\nexport function getTriCount( geo ) {\r\n\r\n\treturn getVertexCount( geo ) / 3;\r\n\r\n}\r\n", "import { Vector3 } from 'three';\r\n\r\nconst DEGENERATE_EPSILON = 1e-8;\r\nconst _tempVec = new Vector3();\r\n\r\nexport function toTriIndex( v ) {\r\n\r\n\treturn ~ ~ ( v / 3 );\r\n\r\n}\r\n\r\nexport function toEdgeIndex( v ) {\r\n\r\n\treturn v % 3;\r\n\r\n}\r\n\r\nexport function sortEdgeFunc( a, b ) {\r\n\r\n\treturn a.start - b.start;\r\n\r\n}\r\n\r\nexport function getProjectedDistance( ray, vec ) {\r\n\r\n\treturn _tempVec.subVectors( vec, ray.origin ).dot( ray.direction );\r\n\r\n}\r\n\r\nexport function hasOverlaps( arr ) {\r\n\r\n\tarr = [ ...arr ].sort( sortEdgeFunc );\r\n\tfor ( let i = 0, l = arr.length; i < l - 1; i ++ ) {\r\n\r\n\t\tconst info0 = arr[ i ];\r\n\t\tconst info1 = arr[ i + 1 ];\r\n\r\n\t\tif ( info1.start < info0.end && Math.abs( info1.start - info0.end ) > 1e-5 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\nexport function getEdgeSetLength( arr ) {\r\n\r\n\tlet tot = 0;\r\n\tarr.forEach( ( { start, end } ) => tot += end - start );\r\n\treturn tot;\r\n\r\n}\r\n\r\nexport function matchEdges( forward, reverse, disjointConnectivityMap, eps = DEGENERATE_EPSILON ) {\r\n\r\n\tforward.sort( sortEdgeFunc );\r\n\treverse.sort( sortEdgeFunc );\r\n\r\n\tfor ( let i = 0; i < forward.length; i ++ ) {\r\n\r\n\t\tconst e0 = forward[ i ];\r\n\t\tfor ( let o = 0; o < reverse.length; o ++ ) {\r\n\r\n\t\t\tconst e1 = reverse[ o ];\r\n\t\t\tif ( e1.start > e0.end ) {\r\n\r\n\t\t\t\t// e2 is completely after e1\r\n\t\t\t\t// break;\r\n\r\n\t\t\t\t// NOTE: there are cases where there are overlaps due to precision issues or\r\n\t\t\t\t// thin / degenerate triangles. Assuming the sibling side has the same issues\r\n\t\t\t\t// we let the matching work here. Long term we should remove the degenerate\r\n\t\t\t\t// triangles before this.\r\n\r\n\t\t\t} else if ( e0.end < e1.start || e1.end < e0.start ) {\r\n\r\n\t\t\t\t// e1 is completely before e2\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t} else if ( e0.start <= e1.start && e0.end >= e1.end ) {\r\n\r\n\t\t\t\t// e1 is larger than and e2 is completely within e1\r\n\t\t\t\tif ( ! areDistancesDegenerate( e1.end, e0.end ) ) {\r\n\r\n\t\t\t\t\tforward.splice( i + 1, 0, {\r\n\t\t\t\t\t\tstart: e1.end,\r\n\t\t\t\t\t\tend: e0.end,\r\n\t\t\t\t\t\tindex: e0.index,\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\te0.end = e1.start;\r\n\r\n\t\t\t\te1.start = 0;\r\n\t\t\t\te1.end = 0;\r\n\r\n\t\t\t} else if ( e0.start >= e1.start && e0.end <= e1.end ) {\r\n\r\n\t\t\t\t// e2 is larger than and e1 is completely within e2\r\n\t\t\t\tif ( ! areDistancesDegenerate( e0.end, e1.end ) ) {\r\n\r\n\t\t\t\t\treverse.splice( o + 1, 0, {\r\n\t\t\t\t\t\tstart: e0.end,\r\n\t\t\t\t\t\tend: e1.end,\r\n\t\t\t\t\t\tindex: e1.index,\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\te1.end = e0.start;\r\n\r\n\t\t\t\te0.start = 0;\r\n\t\t\t\te0.end = 0;\r\n\r\n\t\t\t} else if ( e0.start <= e1.start && e0.end <= e1.end ) {\r\n\r\n\t\t\t\t// e1 overlaps e2 at the beginning\r\n\t\t\t\tconst tmp = e0.end;\r\n\t\t\t\te0.end = e1.start;\r\n\t\t\t\te1.start = tmp;\r\n\r\n\t\t\t} else if ( e0.start >= e1.start && e0.end >= e1.end ) {\r\n\r\n\t\t\t\t// e1 overlaps e2 at the end\r\n\t\t\t\tconst tmp = e1.end;\r\n\t\t\t\te1.end = e0.start;\r\n\t\t\t\te0.start = tmp;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow new Error();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Add the connectivity information\r\n\t\t\tif ( ! disjointConnectivityMap.has( e0.index ) ) {\r\n\r\n\t\t\t\tdisjointConnectivityMap.set( e0.index, [] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! disjointConnectivityMap.has( e1.index ) ) {\r\n\r\n\t\t\t\tdisjointConnectivityMap.set( e1.index, [] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdisjointConnectivityMap\r\n\t\t\t\t.get( e0.index )\r\n\t\t\t\t.push( e1.index );\r\n\r\n\t\t\tdisjointConnectivityMap\r\n\t\t\t\t.get( e1.index )\r\n\t\t\t\t.push( e0.index );\r\n\r\n\t\t\tif ( isEdgeDegenerate( e1 ) ) {\r\n\r\n\t\t\t\treverse.splice( o, 1 );\r\n\t\t\t\to --;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( isEdgeDegenerate( e0 ) ) {\r\n\r\n\t\t\t\t// and if we have to remove the current original edge then exit this loop\r\n\t\t\t\t// so we can work on the next one\r\n\t\t\t\tforward.splice( i, 1 );\r\n\t\t\t\ti --;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcleanUpEdgeSet( forward );\r\n\tcleanUpEdgeSet( reverse );\r\n\r\n\tfunction cleanUpEdgeSet( arr ) {\r\n\r\n\t\tfor ( let i = 0; i < arr.length; i ++ ) {\r\n\r\n\t\t\tif ( isEdgeDegenerate( arr[ i ] ) ) {\r\n\r\n\t\t\t\tarr.splice( i, 1 );\r\n\t\t\t\ti --;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction areDistancesDegenerate( start, end ) {\r\n\r\n\t\treturn Math.abs( end - start ) < eps;\r\n\r\n\t}\r\n\r\n\tfunction isEdgeDegenerate( e ) {\r\n\r\n\t\treturn Math.abs( e.end - e.start ) < eps;\r\n\r\n\t}\r\n\r\n}\r\n", "const DIST_EPSILON = 1e-5;\r\nconst ANGLE_EPSILON = 1e-4;\r\n\r\nexport class RaySet {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis._rays = [];\r\n\r\n\t}\r\n\r\n\taddRay( ray ) {\r\n\r\n\t\tthis._rays.push( ray );\r\n\r\n\t}\r\n\r\n\tfindClosestRay( ray ) {\r\n\r\n\t\tconst rays = this._rays;\r\n\t\tconst inv = ray.clone();\r\n\t\tinv.direction.multiplyScalar( - 1 );\r\n\r\n\t\tlet bestScore = Infinity;\r\n\t\tlet bestRay = null;\r\n\t\tfor ( let i = 0, l = rays.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst r = rays[ i ];\r\n\t\t\tif ( skipRay( r, ray ) && skipRay( r, inv ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst rayScore = scoreRays( r, ray );\r\n\t\t\tconst invScore = scoreRays( r, inv );\r\n\t\t\tconst score = Math.min( rayScore, invScore );\r\n\t\t\tif ( score < bestScore ) {\r\n\r\n\t\t\t\tbestScore = score;\r\n\t\t\t\tbestRay = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bestRay;\r\n\r\n\t\tfunction skipRay( r0, r1 ) {\r\n\r\n\t\t\tconst distOutOfThreshold = r0.origin.distanceTo( r1.origin ) > DIST_EPSILON;\r\n\t\t\tconst angleOutOfThreshold = r0.direction.angleTo( r1.direction ) > ANGLE_EPSILON;\r\n\t\t\treturn angleOutOfThreshold || distOutOfThreshold;\r\n\r\n\t\t}\r\n\r\n\t\tfunction scoreRays( r0, r1 ) {\r\n\r\n\t\t\tconst originDistance = r0.origin.distanceTo( r1.origin );\r\n\t\t\tconst angleDistance = r0.direction.angleTo( r1.direction );\r\n\t\t\treturn originDistance / DIST_EPSILON + angleDistance / ANGLE_EPSILON;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Vector3, Ray } from 'three';\r\nimport { toEdgeIndex, toTriIndex, matchEdges, getProjectedDistance } from './halfEdgeUtils.js';\r\nimport { toNormalizedRay } from './hashUtils.js';\r\nimport { RaySet } from './RaySet.js';\r\n\r\nconst _v0 = new Vector3();\r\nconst _v1 = new Vector3();\r\nconst _ray = new Ray();\r\n\r\nexport function computeDisjointEdges(\r\n\tgeometry,\r\n\tunmatchedSet,\r\n\teps,\r\n) {\r\n\r\n\tconst attributes = geometry.attributes;\r\n\tconst indexAttr = geometry.index;\r\n\tconst posAttr = attributes.position;\r\n\r\n\tconst disjointConnectivityMap = new Map();\r\n\tconst fragmentMap = new Map();\r\n\tconst edges = Array.from( unmatchedSet );\r\n\tconst rays = new RaySet();\r\n\r\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\r\n\r\n\t\t// get the triangle edge\r\n\t\tconst index = edges[ i ];\r\n\t\tconst triIndex = toTriIndex( index );\r\n\t\tconst edgeIndex = toEdgeIndex( index );\r\n\r\n\t\tlet i0 = 3 * triIndex + edgeIndex;\r\n\t\tlet i1 = 3 * triIndex + ( edgeIndex + 1 ) % 3;\r\n\t\tif ( indexAttr ) {\r\n\r\n\t\t\ti0 = indexAttr.getX( i0 );\r\n\t\t\ti1 = indexAttr.getX( i1 );\r\n\r\n\t\t}\r\n\r\n\t\t_v0.fromBufferAttribute( posAttr, i0 );\r\n\t\t_v1.fromBufferAttribute( posAttr, i1 );\r\n\r\n\t\t// get the ray corresponding to the edge\r\n\t\ttoNormalizedRay( _v0, _v1, _ray );\r\n\r\n\t\t// find the shared ray with other edges\r\n\t\tlet info;\r\n\t\tlet commonRay = rays.findClosestRay( _ray );\r\n\t\tif ( commonRay === null ) {\r\n\r\n\t\t\tcommonRay = _ray.clone();\r\n\t\t\trays.addRay( commonRay );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! fragmentMap.has( commonRay ) ) {\r\n\r\n\t\t\tfragmentMap.set( commonRay, {\r\n\r\n\t\t\t\tforward: [],\r\n\t\t\t\treverse: [],\r\n\t\t\t\tray: commonRay,\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tinfo = fragmentMap.get( commonRay );\r\n\r\n\t\t// store the stride of edge endpoints along the ray\r\n\t\tlet start = getProjectedDistance( commonRay, _v0 );\r\n\t\tlet end = getProjectedDistance( commonRay, _v1 );\r\n\t\tif ( start > end ) {\r\n\r\n\t\t\t[ start, end ] = [ end, start ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( _ray.direction.dot( commonRay.direction ) < 0 ) {\r\n\r\n\t\t\tinfo.reverse.push( { start, end, index } );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tinfo.forward.push( { start, end, index } );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// match the found sibling edges\r\n\tfragmentMap.forEach( ( { forward, reverse }, ray ) => {\r\n\r\n\t\tmatchEdges( forward, reverse, disjointConnectivityMap, eps );\r\n\r\n\t\tif ( forward.length === 0 && reverse.length === 0 ) {\r\n\r\n\t\t\tfragmentMap.delete( ray );\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn {\r\n\t\tdisjointConnectivityMap,\r\n\t\tfragmentMap,\r\n\t};\r\n\r\n}\r\n\r\n", "import { Vector2, Vector3, Vector4 } from 'three';\r\nimport { hashNumber, hashVertex2, hashVertex3, hashVertex4 } from './utils/hashUtils.js';\r\nimport { getTriCount } from './utils/geometryUtils.js';\r\nimport { computeDisjointEdges } from './utils/computeDisjointEdges.js';\r\n\r\nconst _vec2 = new Vector2();\r\nconst _vec3 = new Vector3();\r\nconst _vec4 = new Vector4();\r\nconst _hashes = [ '', '', '' ];\r\n\r\nexport class HalfEdgeMap {\r\n\r\n\tconstructor( geometry = null ) {\r\n\r\n\t\t// result data\r\n\t\tthis.data = null;\r\n\t\tthis.disjointConnections = null;\r\n\t\tthis.unmatchedDisjointEdges = null;\r\n\t\tthis.unmatchedEdges = - 1;\r\n\t\tthis.matchedEdges = - 1;\r\n\r\n\t\t// options\r\n\t\tthis.useDrawRange = true;\r\n\t\tthis.useAllAttributes = false;\r\n\t\tthis.matchDisjointEdges = false;\r\n\t\tthis.degenerateEpsilon = 1e-8;\r\n\r\n\t\tif ( geometry ) {\r\n\r\n\t\t\tthis.updateFrom( geometry );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetSiblingTriangleIndex( triIndex, edgeIndex ) {\r\n\r\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\r\n\t\treturn otherIndex === - 1 ? - 1 : ~ ~ ( otherIndex / 3 );\r\n\r\n\t}\r\n\r\n\tgetSiblingEdgeIndex( triIndex, edgeIndex ) {\r\n\r\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\r\n\t\treturn otherIndex === - 1 ? - 1 : ( otherIndex % 3 );\r\n\r\n\t}\r\n\r\n\tgetDisjointSiblingTriangleIndices( triIndex, edgeIndex ) {\r\n\r\n\t\tconst index = triIndex * 3 + edgeIndex;\r\n\t\tconst arr = this.disjointConnections.get( index );\r\n\t\treturn arr ? arr.map( i => ~ ~ ( i / 3 ) ) : [];\r\n\r\n\t}\r\n\r\n\tgetDisjointSiblingEdgeIndices( triIndex, edgeIndex ) {\r\n\r\n\t\tconst index = triIndex * 3 + edgeIndex;\r\n\t\tconst arr = this.disjointConnections.get( index );\r\n\t\treturn arr ? arr.map( i => i % 3 ) : [];\r\n\r\n\t}\r\n\r\n\tisFullyConnected() {\r\n\r\n\t\treturn this.unmatchedEdges === 0;\r\n\r\n\t}\r\n\r\n\tupdateFrom( geometry ) {\r\n\r\n\t\tconst { useAllAttributes, useDrawRange, matchDisjointEdges, degenerateEpsilon } = this;\r\n\t\tconst hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;\r\n\r\n\t\t// runs on the assumption that there is a 1 : 1 match of edges\r\n\t\tconst map = new Map();\r\n\r\n\t\t// attributes\r\n\t\tconst { attributes } = geometry;\r\n\t\tconst attrKeys = useAllAttributes ? Object.keys( attributes ) : null;\r\n\t\tconst indexAttr = geometry.index;\r\n\t\tconst posAttr = attributes.position;\r\n\r\n\t\t// get the potential number of triangles\r\n\t\tlet triCount = getTriCount( geometry );\r\n\t\tconst maxTriCount = triCount;\r\n\r\n\t\t// get the real number of triangles from the based on the draw range\r\n\t\tlet offset = 0;\r\n\t\tif ( useDrawRange ) {\r\n\r\n\t\t\toffset = geometry.drawRange.start;\r\n\t\t\tif ( geometry.drawRange.count !== Infinity ) {\r\n\r\n\t\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// initialize the connectivity buffer - 1 means no connectivity\r\n\t\tlet data = this.data;\r\n\t\tif ( ! data || data.length < 3 * maxTriCount ) {\r\n\r\n\t\t\tdata = new Int32Array( 3 * maxTriCount );\r\n\r\n\t\t}\r\n\r\n\t\tdata.fill( - 1 );\r\n\r\n\t\t// iterate over all triangles\r\n\t\tlet matchedEdges = 0;\r\n\t\tlet unmatchedSet = new Set();\r\n\t\tfor ( let i = offset, l = triCount * 3 + offset; i < l; i += 3 ) {\r\n\r\n\t\t\tconst i3 = i;\r\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\tlet i0 = i3 + e;\r\n\t\t\t\tif ( indexAttr ) {\r\n\r\n\t\t\t\t\ti0 = indexAttr.getX( i0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_hashes[ e ] = hashFunction( i0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\tconst nextE = ( e + 1 ) % 3;\r\n\t\t\t\tconst vh0 = _hashes[ e ];\r\n\t\t\t\tconst vh1 = _hashes[ nextE ];\r\n\r\n\t\t\t\tconst reverseHash = `${ vh1 }_${ vh0 }`;\r\n\t\t\t\tif ( map.has( reverseHash ) ) {\r\n\r\n\t\t\t\t\t// create a reference between the two triangles and clear the hash\r\n\t\t\t\t\tconst index = i3 + e;\r\n\t\t\t\t\tconst otherIndex = map.get( reverseHash );\r\n\t\t\t\t\tdata[ index ] = otherIndex;\r\n\t\t\t\t\tdata[ otherIndex ] = index;\r\n\t\t\t\t\tmap.delete( reverseHash );\r\n\t\t\t\t\tmatchedEdges += 2;\r\n\t\t\t\t\tunmatchedSet.delete( otherIndex );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// save the triangle and triangle edge index captured in one value\r\n\t\t\t\t\t// triIndex = ~ ~ ( i0 / 3 );\r\n\t\t\t\t\t// edgeIndex = i0 % 3;\r\n\t\t\t\t\tconst hash = `${ vh0 }_${ vh1 }`;\r\n\t\t\t\t\tconst index = i3 + e;\r\n\t\t\t\t\tmap.set( hash, index );\r\n\t\t\t\t\tunmatchedSet.add( index );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( matchDisjointEdges ) {\r\n\r\n\t\t\tconst {\r\n\t\t\t\tfragmentMap,\r\n\t\t\t\tdisjointConnectivityMap,\r\n\t\t\t} = computeDisjointEdges( geometry, unmatchedSet, degenerateEpsilon );\r\n\r\n\t\t\tunmatchedSet.clear();\r\n\t\t\tfragmentMap.forEach( ( { forward, reverse } ) => {\r\n\r\n\t\t\t\tforward.forEach( ( { index } ) => unmatchedSet.add( index ) );\r\n\t\t\t\treverse.forEach( ( { index } ) => unmatchedSet.add( index ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tthis.unmatchedDisjointEdges = fragmentMap;\r\n\t\t\tthis.disjointConnections = disjointConnectivityMap;\r\n\t\t\tmatchedEdges = triCount * 3 - unmatchedSet.size;\r\n\r\n\t\t}\r\n\r\n\t\tthis.matchedEdges = matchedEdges;\r\n\t\tthis.unmatchedEdges = unmatchedSet.size;\r\n\t\tthis.data = data;\r\n\r\n\t\tfunction hashPositionAttribute( i ) {\r\n\r\n\t\t\t_vec3.fromBufferAttribute( posAttr, i );\r\n\t\t\treturn hashVertex3( _vec3 );\r\n\r\n\t\t}\r\n\r\n\t\tfunction hashAllAttributes( i ) {\r\n\r\n\t\t\tlet result = '';\r\n\t\t\tfor ( let k = 0, l = attrKeys.length; k < l; k ++ ) {\r\n\r\n\t\t\t\tconst attr = attributes[ attrKeys[ k ] ];\r\n\t\t\t\tlet str;\r\n\t\t\t\tswitch ( attr.itemSize ) {\r\n\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tstr = hashNumber( attr.getX( i ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\tstr = hashVertex2( _vec2.fromBufferAttribute( attr, i ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\tstr = hashVertex3( _vec3.fromBufferAttribute( attr, i ) );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tstr = hashVertex4( _vec4.fromBufferAttribute( attr, i ) );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( result !== '' ) {\r\n\r\n\t\t\t\t\tresult += '|';\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult += str;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Mesh, Matrix4 } from 'three';\r\nimport { MeshBVH } from 'three-mesh-bvh';\r\nimport { HalfEdgeMap } from './HalfEdgeMap.js';\r\nimport { areSharedArrayBuffersSupported, convertToSharedArrayBuffer, ensureIndex, getTriCount } from './utils/geometryUtils.js';\r\n\r\nexport class Brush extends Mesh {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isBrush = true;\r\n\t\tthis._previousMatrix = new Matrix4();\r\n\t\tthis._previousMatrix.elements.fill( 0 );\r\n\r\n\t}\r\n\r\n\tmarkUpdated() {\r\n\r\n\t\tthis._previousMatrix.copy( this.matrix );\r\n\r\n\t}\r\n\r\n\tisDirty() {\r\n\r\n\t\tconst { matrix, _previousMatrix } = this;\r\n\t\tconst el1 = matrix.elements;\r\n\t\tconst el2 = _previousMatrix.elements;\r\n\t\tfor ( let i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tprepareGeometry() {\r\n\r\n\t\t// generate shared array buffers\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst attributes = geometry.attributes;\r\n\t\tconst useSharedArrayBuffer = areSharedArrayBuffersSupported();\r\n\t\tif ( useSharedArrayBuffer ) {\r\n\r\n\t\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\t\tconst attribute = attributes[ key ];\r\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'Brush: InterleavedBufferAttributes are not supported.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tattribute.array = convertToSharedArrayBuffer( attribute.array );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// generate bounds tree\r\n\t\tif ( ! geometry.boundsTree ) {\r\n\r\n\t\t\tensureIndex( geometry, { useSharedArrayBuffer } );\r\n\t\t\tgeometry.boundsTree = new MeshBVH( geometry, { maxLeafTris: 3, indirect: true, useSharedArrayBuffer } );\r\n\r\n\t\t}\r\n\r\n\t\t// generate half edges\r\n\t\tif ( ! geometry.halfEdges ) {\r\n\r\n\t\t\tgeometry.halfEdges = new HalfEdgeMap( geometry );\r\n\r\n\t\t}\r\n\r\n\t\t// save group indices for materials\r\n\t\tif ( ! geometry.groupIndices ) {\r\n\r\n\t\t\tconst triCount = getTriCount( geometry );\r\n\t\t\tconst array = new Uint16Array( triCount );\r\n\t\t\tconst groups = geometry.groups;\r\n\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst { start, count } = groups[ i ];\r\n\t\t\t\tfor ( let g = start / 3, lg = ( start + count ) / 3; g < lg; g ++ ) {\r\n\r\n\t\t\t\t\tarray[ g ] = i;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.groupIndices = array;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdisposeCacheData() {\r\n\r\n\t\tconst { geometry } = this;\r\n\t\tgeometry.halfEdges = null;\r\n\t\tgeometry.boundsTree = null;\r\n\t\tgeometry.groupIndices = null;\r\n\r\n\t}\r\n\r\n}\r\n", "import { Vector3 } from 'three';\r\n\r\nconst EPSILON = 1e-14;\r\nconst _AB = new Vector3();\r\nconst _AC = new Vector3();\r\nconst _CB = new Vector3();\r\n\r\nexport function isTriDegenerate( tri, eps = EPSILON ) {\r\n\r\n\t// compute angles to determine whether they're degenerate\r\n\t_AB.subVectors( tri.b, tri.a );\r\n\t_AC.subVectors( tri.c, tri.a );\r\n\t_CB.subVectors( tri.b, tri.c );\r\n\r\n\tconst angle1 = _AB.angleTo( _AC );\t\t\t\t// AB v AC\r\n\tconst angle2 = _AB.angleTo( _CB );\t\t\t\t// AB v BC\r\n\tconst angle3 = Math.PI - angle1 - angle2;\t\t// 180deg - angle1 - angle2\r\n\r\n\treturn Math.abs( angle1 ) < eps ||\r\n\t\tMath.abs( angle2 ) < eps ||\r\n\t\tMath.abs( angle3 ) < eps ||\r\n\t\ttri.a.distanceToSquared( tri.b ) < eps ||\r\n\t\ttri.a.distanceToSquared( tri.c ) < eps ||\r\n\t\ttri.b.distanceToSquared( tri.c ) < eps;\r\n\r\n}\r\n", "import { Triangle, Line3, Vector3, Plane } from 'three';\r\nimport { ExtendedTriangle } from 'three-mesh-bvh';\r\nimport { isTriDegenerate } from './utils/triangleUtils.js';\r\n\r\n// NOTE: these epsilons likely should all be the same since they're used to measure the\r\n// distance from a point to a plane which needs to be done consistently\r\nconst EPSILON = 1e-10;\r\nconst COPLANAR_EPSILON = 1e-10;\r\nconst PARALLEL_EPSILON = 1e-10;\r\nconst _edge = new Line3();\r\nconst _foundEdge = new Line3();\r\nconst _vec = new Vector3();\r\nconst _triangleNormal = new Vector3();\r\nconst _planeNormal = new Vector3();\r\nconst _plane = new Plane();\r\nconst _splittingTriangle = new ExtendedTriangle();\r\n\r\n// A pool of triangles to avoid unnecessary triangle creation\r\nclass TrianglePool {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis._pool = [];\r\n\t\tthis._index = 0;\r\n\r\n\t}\r\n\r\n\tgetTriangle() {\r\n\r\n\t\tif ( this._index >= this._pool.length ) {\r\n\r\n\t\t\tthis._pool.push( new Triangle() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this._pool[ this._index ++ ];\r\n\r\n\t}\r\n\r\n\tclear() {\r\n\r\n\t\tthis._index = 0;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis._pool.length = 0;\r\n\t\tthis._index = 0;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Utility class for splitting triangles\r\nexport class TriangleSplitter {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.trianglePool = new TrianglePool();\r\n\t\tthis.triangles = [];\r\n\t\tthis.normal = new Vector3();\r\n\t\tthis.coplanarTriangleUsed = false;\r\n\r\n\t}\r\n\r\n\t// initialize the class with a triangle\r\n\tinitialize( tri ) {\r\n\r\n\t\tthis.reset();\r\n\r\n\t\tconst { triangles, trianglePool, normal } = this;\r\n\t\tif ( Array.isArray( tri ) ) {\r\n\r\n\t\t\tfor ( let i = 0, l = tri.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst t = tri[ i ];\r\n\t\t\t\tif ( i === 0 ) {\r\n\r\n\t\t\t\t\tt.getNormal( normal );\r\n\r\n\t\t\t\t} else if ( Math.abs( 1.0 - t.getNormal( _vec ).dot( normal ) ) > EPSILON ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'Triangle Splitter: Cannot initialize with triangles that have different normals.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst poolTri = trianglePool.getTriangle();\r\n\t\t\t\tpoolTri.copy( t );\r\n\t\t\t\ttriangles.push( poolTri );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttri.getNormal( normal );\r\n\r\n\t\t\tconst poolTri = trianglePool.getTriangle();\r\n\t\t\tpoolTri.copy( tri );\r\n\t\t\ttriangles.push( poolTri );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Split the current set of triangles by passing a single triangle in. If the triangle is\r\n\t// coplanar it will attempt to split by the triangle edge planes\r\n\tsplitByTriangle( triangle ) {\r\n\r\n\t\tconst { normal, triangles } = this;\r\n\t\ttriangle.getNormal( _triangleNormal ).normalize();\r\n\r\n\t\tif ( Math.abs( 1.0 - Math.abs( _triangleNormal.dot( normal ) ) ) < PARALLEL_EPSILON ) {\r\n\r\n\t\t\tthis.coplanarTriangleUsed = true;\r\n\r\n\t\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst t = triangles[ i ];\r\n\t\t\t\tt.coplanarCount = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// if the triangle is coplanar then split by the edge planes\r\n\t\t\tconst arr = [ triangle.a, triangle.b, triangle.c ];\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\r\n\r\n\t\t\t\tconst v0 = arr[ i ];\r\n\t\t\t\tconst v1 = arr[ nexti ];\r\n\r\n\t\t\t\t// plane positive direction is toward triangle center\r\n\t\t\t\t_vec.subVectors( v1, v0 ).normalize();\r\n\t\t\t\t_planeNormal.crossVectors( _triangleNormal, _vec );\r\n\t\t\t\t_plane.setFromNormalAndCoplanarPoint( _planeNormal, v0 );\r\n\r\n\t\t\t\tthis.splitByPlane( _plane, triangle );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// otherwise split by the triangle plane\r\n\t\t\ttriangle.getPlane( _plane );\r\n\t\t\tthis.splitByPlane( _plane, triangle );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Split the triangles by the given plan. If a triangle is provided then we ensure we\r\n\t// intersect the triangle before splitting the plane\r\n\tsplitByPlane( plane, clippingTriangle ) {\r\n\r\n\t\tconst { triangles, trianglePool } = this;\r\n\r\n\t\t// init our triangle to check for intersection\r\n\t\t_splittingTriangle.copy( clippingTriangle );\r\n\t\t_splittingTriangle.needsUpdate = true;\r\n\r\n\t\t// try to split every triangle in the class\r\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst tri = triangles[ i ];\r\n\r\n\t\t\t// skip the triangle if we don't intersect with it\r\n\t\t\tif ( ! _splittingTriangle.intersectsTriangle( tri, _edge, true ) ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst { a, b, c } = tri;\r\n\t\t\tlet intersects = 0;\r\n\t\t\tlet vertexSplitEnd = - 1;\r\n\t\t\tlet coplanarEdge = false;\r\n\t\t\tlet posSideVerts = [];\r\n\t\t\tlet negSideVerts = [];\r\n\t\t\tconst arr = [ a, b, c ];\r\n\t\t\tfor ( let t = 0; t < 3; t ++ ) {\r\n\r\n\t\t\t\t// get the triangle edge\r\n\t\t\t\tconst tNext = ( t + 1 ) % 3;\r\n\t\t\t\t_edge.start.copy( arr[ t ] );\r\n\t\t\t\t_edge.end.copy( arr[ tNext ] );\r\n\r\n\t\t\t\t// track if the start point sits on the plane or if it's on the positive side of it\r\n\t\t\t\t// so we can use that information to determine whether to split later.\r\n\t\t\t\tconst startDist = plane.distanceToPoint( _edge.start );\r\n\t\t\t\tconst endDist = plane.distanceToPoint( _edge.end );\r\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON && Math.abs( endDist ) < COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\t\tcoplanarEdge = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( startDist > 0 ) {\r\n\r\n\t\t\t\t\tposSideVerts.push( t );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnegSideVerts.push( t );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// we only don't consider this an intersection if the start points hits the plane\r\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// double check the end point since the \"intersectLine\" function sometimes does not\r\n\t\t\t\t// return it as an intersection (see issue #28)\r\n\t\t\t\t// Because we ignore the start point intersection above we have to make sure we check the end\r\n\t\t\t\t// point intersection here.\r\n\t\t\t\tlet didIntersect = ! ! plane.intersectLine( _edge, _vec );\r\n\t\t\t\tif ( ! didIntersect && Math.abs( endDist ) < COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\t\t_vec.copy( _edge.end );\r\n\t\t\t\t\tdidIntersect = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// check if we intersect the plane (ignoring the start point so we don't double count)\r\n\t\t\t\tif ( didIntersect && ! ( _vec.distanceTo( _edge.start ) < EPSILON ) ) {\r\n\r\n\t\t\t\t\t// if we intersect at the end point then we track that point as one that we\r\n\t\t\t\t\t// have to split down the middle\r\n\t\t\t\t\tif ( _vec.distanceTo( _edge.end ) < EPSILON ) {\r\n\r\n\t\t\t\t\t\tvertexSplitEnd = t;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// track the split edge\r\n\t\t\t\t\tif ( intersects === 0 ) {\r\n\r\n\t\t\t\t\t\t_foundEdge.start.copy( _vec );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t_foundEdge.end.copy( _vec );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tintersects ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// skip splitting if:\r\n\t\t\t// - we have two points on the plane then the plane intersects the triangle exactly on an edge\r\n\t\t\t// - the plane does not intersect on 2 points\r\n\t\t\t// - the intersection edge is too small\r\n\t\t\t// - we're not along a coplanar edge\r\n\t\t\tif ( ! coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\tif ( vertexSplitEnd !== - 1 ) {\r\n\r\n\t\t\t\t\tvertexSplitEnd = ( vertexSplitEnd + 1 ) % 3;\r\n\r\n\t\t\t\t\t// we're splitting along a vertex\r\n\t\t\t\t\tlet otherVert1 = 0;\r\n\t\t\t\t\tif ( otherVert1 === vertexSplitEnd ) {\r\n\r\n\t\t\t\t\t\totherVert1 = ( otherVert1 + 1 ) % 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet otherVert2 = otherVert1 + 1;\r\n\t\t\t\t\tif ( otherVert2 === vertexSplitEnd ) {\r\n\r\n\t\t\t\t\t\totherVert2 = ( otherVert2 + 1 ) % 3;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst nextTri = trianglePool.getTriangle();\r\n\t\t\t\t\tnextTri.a.copy( arr[ otherVert2 ] );\r\n\t\t\t\t\tnextTri.b.copy( _foundEdge.end );\r\n\t\t\t\t\tnextTri.c.copy( _foundEdge.start );\r\n\r\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.push( nextTri );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttri.a.copy( arr[ otherVert1 ] );\r\n\t\t\t\t\ttri.b.copy( _foundEdge.start );\r\n\t\t\t\t\ttri.c.copy( _foundEdge.end );\r\n\r\n\t\t\t\t\t// finish off the adjusted triangle\r\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.splice( i, 1 );\r\n\t\t\t\t\t\ti --;\r\n\t\t\t\t\t\tl --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// we're splitting with a quad and a triangle\r\n\t\t\t\t\t// TODO: what happens when we find that about the pos and negative\r\n\t\t\t\t\t// sides have only a single vertex?\r\n\t\t\t\t\tconst singleVert =\r\n\t\t\t\t\t\tposSideVerts.length >= 2 ?\r\n\t\t\t\t\t\t\tnegSideVerts[ 0 ] :\r\n\t\t\t\t\t\t\tposSideVerts[ 0 ];\r\n\r\n\t\t\t\t\t// swap the direction of the intersection edge depending on which\r\n\t\t\t\t\t// side of the plane the single vertex is on to align with the\r\n\t\t\t\t\t// correct winding order.\r\n\t\t\t\t\tif ( singleVert === 0 ) {\r\n\r\n\t\t\t\t\t\tlet tmp = _foundEdge.start;\r\n\t\t\t\t\t\t_foundEdge.start = _foundEdge.end;\r\n\t\t\t\t\t\t_foundEdge.end = tmp;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst nextVert1 = ( singleVert + 1 ) % 3;\r\n\t\t\t\t\tconst nextVert2 = ( singleVert + 2 ) % 3;\r\n\r\n\t\t\t\t\tconst nextTri1 = trianglePool.getTriangle();\r\n\t\t\t\t\tconst nextTri2 = trianglePool.getTriangle();\r\n\r\n\t\t\t\t\t// choose the triangle that has the larger areas (shortest split distance)\r\n\t\t\t\t\tif ( arr[ nextVert1 ].distanceToSquared( _foundEdge.start ) < arr[ nextVert2 ].distanceToSquared( _foundEdge.end ) ) {\r\n\r\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert1 ] );\r\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\r\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\r\n\r\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\r\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\r\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.start );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert2 ] );\r\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\r\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\r\n\r\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\r\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\r\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.end );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttri.a.copy( arr[ singleVert ] );\r\n\t\t\t\t\ttri.b.copy( _foundEdge.end );\r\n\t\t\t\t\ttri.c.copy( _foundEdge.start );\r\n\r\n\t\t\t\t\t// don't add degenerate triangles to the list\r\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri1 ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.push( nextTri1 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri2 ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.push( nextTri2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// finish off the adjusted triangle\r\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\r\n\r\n\t\t\t\t\t\ttriangles.splice( i, 1 );\r\n\t\t\t\t\t\ti --;\r\n\t\t\t\t\t\tl --;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( intersects === 3 ) {\r\n\r\n\t\t\t\tconsole.warn( 'TriangleClipper: Coplanar clip not handled' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.triangles.length = 0;\r\n\t\tthis.trianglePool.clear();\r\n\t\tthis.coplanarTriangleUsed = false;\r\n\r\n\t}\r\n\r\n}\r\n", "import { areSharedArrayBuffersSupported } from './utils/geometryUtils.js';\r\n\r\nfunction ceilToFourByteStride( byteLength ) {\r\n\r\n\tbyteLength = ~ ~ byteLength;\r\n\treturn byteLength + 4 - byteLength % 4;\r\n\r\n}\r\n\r\n// Make a new array wrapper class that more easily affords expansion when reaching it's max capacity\r\nexport class TypeBackedArray {\r\n\r\n\tconstructor( type, initialSize = 500 ) {\r\n\r\n\r\n\t\tthis.expansionFactor = 1.5;\r\n\t\tthis.type = type;\r\n\t\tthis.length = 0;\r\n\t\tthis.array = null;\r\n\r\n\t\tthis.setSize( initialSize );\r\n\r\n\t}\r\n\r\n\tsetType( type ) {\r\n\r\n\t\tif ( this.length !== 0 ) {\r\n\r\n\t\t\tthrow new Error( 'TypeBackedArray: Cannot change the type while there is used data in the buffer.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst buffer = this.array.buffer;\r\n\t\tthis.array = new type( buffer );\r\n\t\tthis.type = type;\r\n\r\n\t}\r\n\r\n\tsetSize( size ) {\r\n\r\n\t\tif ( this.array && size === this.array.length ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// ceil to the nearest 4 bytes so we can replace the array with any type using the same buffer\r\n\t\tconst type = this.type;\r\n\t\tconst bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tconst newArray = new type( new bufferType( ceilToFourByteStride( size * type.BYTES_PER_ELEMENT ) ) );\r\n\t\tif ( this.array ) {\r\n\r\n\t\t\tnewArray.set( this.array, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tthis.array = newArray;\r\n\r\n\t}\r\n\r\n\texpand() {\r\n\r\n\t\tconst { array, expansionFactor } = this;\r\n\t\tthis.setSize( array.length * expansionFactor );\r\n\r\n\t}\r\n\r\n\tpush( ...args ) {\r\n\r\n\t\tlet { array, length } = this;\r\n\t\tif ( length + args.length > array.length ) {\r\n\r\n\t\t\tthis.expand();\r\n\t\t\tarray = this.array;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\r\n\r\n\t\t\tarray[ length + i ] = args[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.length += args.length;\r\n\r\n\t}\r\n\r\n\tclear() {\r\n\r\n\t\tthis.length = 0;\r\n\r\n\t}\r\n\r\n}\r\n", "import { TypeBackedArray } from './TypeBackedArray.js';\r\n\r\n// Utility class for for tracking attribute data in type-backed arrays for a set\r\n// of groups. The set of attributes is kept for each group and are expected to be the\r\n// same buffer type.\r\nexport class TypedAttributeData {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.groupAttributes = [ {} ];\r\n\t\tthis.groupCount = 0;\r\n\r\n\t}\r\n\r\n\t// returns the buffer type for the given attribute\r\n\tgetType( name ) {\r\n\r\n\t\treturn this.groupAttributes[ 0 ][ name ].type;\r\n\r\n\t}\r\n\r\n\tgetItemSize( name ) {\r\n\r\n\t\treturn this.groupAttributes[ 0 ][ name ].itemSize;\r\n\r\n\t}\r\n\r\n\tgetNormalized( name ) {\r\n\r\n\t\treturn this.groupAttributes[ 0 ][ name ].normalized;\r\n\r\n\t}\r\n\r\n\tgetCount( index ) {\r\n\r\n\t\tif ( this.groupCount <= index ) {\r\n\r\n\t\t\treturn 0;\r\n\r\n\t\t}\r\n\r\n\t\tconst pos = this.getGroupAttrArray( 'position', index );\r\n\t\treturn pos.length / pos.itemSize;\r\n\r\n\t}\r\n\r\n\t// returns the total length required for all groups for the given attribute\r\n\tgetTotalLength( name ) {\r\n\r\n\t\tconst { groupCount, groupAttributes } = this;\r\n\r\n\t\tlet length = 0;\r\n\t\tfor ( let i = 0; i < groupCount; i ++ ) {\r\n\r\n\t\t\tconst attrSet = groupAttributes[ i ];\r\n\t\t\tlength += attrSet[ name ].length;\r\n\r\n\t\t}\r\n\r\n\t\treturn length;\r\n\r\n\t}\r\n\r\n\tgetGroupAttrSet( index = 0 ) {\r\n\r\n\t\t// TODO: can this be abstracted?\r\n\t\t// Return the exiting group set if necessary\r\n\t\tconst { groupAttributes } = this;\r\n\t\tif ( groupAttributes[ index ] ) {\r\n\r\n\t\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\r\n\t\t\treturn groupAttributes[ index ];\r\n\r\n\t\t}\r\n\r\n\t\t// add any new group sets required\r\n\t\tconst refAttrSet = groupAttributes[ 0 ];\r\n\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\r\n\t\twhile ( index >= groupAttributes.length ) {\r\n\r\n\t\t\tconst newAttrSet = {};\r\n\t\t\tgroupAttributes.push( newAttrSet );\r\n\t\t\tfor ( const key in refAttrSet ) {\r\n\r\n\t\t\t\tconst refAttr = refAttrSet[ key ];\r\n\t\t\t\tconst newAttr = new TypeBackedArray( refAttr.type );\r\n\t\t\t\tnewAttr.itemSize = refAttr.itemSize;\r\n\t\t\t\tnewAttr.normalized = refAttr.normalized;\r\n\t\t\t\tnewAttrSet[ key ] = newAttr;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn groupAttributes[ index ];\r\n\r\n\t}\r\n\r\n\t// Get the raw array for the group set of data\r\n\tgetGroupAttrArray( name, index = 0 ) {\r\n\r\n\t\t// throw an error if we've never\r\n\t\tconst { groupAttributes } = this;\r\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\r\n\t\tconst referenceAttr = referenceAttrSet[ name ];\r\n\t\tif ( ! referenceAttr ) {\r\n\r\n\t\t\tthrow new Error( `TypedAttributeData: Attribute with \"${ name }\" has not been initialized` );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.getGroupAttrSet( index )[ name ];\r\n\r\n\t}\r\n\r\n\t// initializes an attribute array with the given name, type, and size\r\n\tinitializeArray( name, type, itemSize, normalized ) {\r\n\r\n\t\tconst { groupAttributes } = this;\r\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\r\n\t\tconst referenceAttr = referenceAttrSet[ name ];\r\n\t\tif ( referenceAttr ) {\r\n\r\n\t\t\tif ( referenceAttr.type !== type ) {\r\n\r\n\t\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst arr = groupAttributes[ i ][ name ];\r\n\t\t\t\t\tarr.setType( type );\r\n\t\t\t\t\tarr.itemSize = itemSize;\r\n\t\t\t\t\tarr.normalized = normalized;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst arr = new TypeBackedArray( type );\r\n\t\t\t\tarr.itemSize = itemSize;\r\n\t\t\t\tarr.normalized = normalized;\r\n\t\t\t\tgroupAttributes[ i ][ name ] = arr;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Clear all the data\r\n\tclear() {\r\n\r\n\t\tthis.groupCount = 0;\r\n\r\n\t\tconst { groupAttributes } = this;\r\n\t\tgroupAttributes.forEach( attrSet => {\r\n\r\n\t\t\tfor ( const key in attrSet ) {\r\n\r\n\t\t\t\tattrSet[ key ].clear();\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// Remove the given key\r\n\tdelete( key ) {\r\n\r\n\t\tthis.groupAttributes.forEach( attrSet => {\r\n\r\n\t\t\tdelete attrSet[ key ];\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// Reset the datasets completely\r\n\treset() {\r\n\r\n\t\tthis.groupAttributes = [];\r\n\t\tthis.groupCount = 0;\r\n\r\n\t}\r\n\r\n}\r\n", "export class IntersectionMap {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.intersectionSet = {};\r\n\t\tthis.ids = [];\r\n\r\n\t}\r\n\r\n\tadd( id, intersectionId ) {\r\n\r\n\t\tconst { intersectionSet, ids } = this;\r\n\t\tif ( ! intersectionSet[ id ] ) {\r\n\r\n\t\t\tintersectionSet[ id ] = [];\r\n\t\t\tids.push( id );\r\n\r\n\t\t}\r\n\r\n\t\tintersectionSet[ id ].push( intersectionId );\r\n\r\n\t}\r\n\r\n}\r\n", "export const ADDITION = 0;\r\nexport const SUBTRACTION = 1;\r\nexport const REVERSE_SUBTRACTION = 2;\r\nexport const INTERSECTION = 3;\r\nexport const DIFFERENCE = 4;\r\n\r\n// guaranteed non manifold results\r\nexport const HOLLOW_SUBTRACTION = 5;\r\nexport const HOLLOW_INTERSECTION = 6;\r\n", "import { Ray, Matrix4, DoubleSide, Vector3, Vector4, Triangle, Line3 } from 'three';\r\nimport { IntersectionMap } from '../IntersectionMap.js';\r\nimport {\r\n\tADDITION,\r\n\tSUBTRACTION,\r\n\tREVERSE_SUBTRACTION,\r\n\tINTERSECTION,\r\n\tDIFFERENCE,\r\n\tHOLLOW_SUBTRACTION,\r\n\tHOLLOW_INTERSECTION,\r\n} from '../constants.js';\r\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\r\n\r\nconst _ray = new Ray();\r\nconst _matrix = new Matrix4();\r\nconst _tri = new Triangle();\r\nconst _vec3 = new Vector3();\r\nconst _vec4a = new Vector4();\r\nconst _vec4b = new Vector4();\r\nconst _vec4c = new Vector4();\r\nconst _vec4_0 = new Vector4();\r\nconst _vec4_1 = new Vector4();\r\nconst _vec4_2 = new Vector4();\r\nconst _edge = new Line3();\r\nconst _normal = new Vector3();\r\nconst JITTER_EPSILON = 1e-8;\r\nconst OFFSET_EPSILON = 1e-15;\r\n\r\nexport const BACK_SIDE = - 1;\r\nexport const FRONT_SIDE = 1;\r\nexport const COPLANAR_OPPOSITE = - 2;\r\nexport const COPLANAR_ALIGNED = 2;\r\n\r\nexport const INVERT_TRI = 0;\r\nexport const ADD_TRI = 1;\r\nexport const SKIP_TRI = 2;\r\n\r\nconst FLOATING_COPLANAR_EPSILON = 1e-14;\r\n\r\nlet _debugContext = null;\r\nexport function setDebugContext( debugData ) {\r\n\r\n\t_debugContext = debugData;\r\n\r\n}\r\n\r\nexport function getHitSide( tri, bvh ) {\r\n\r\n\ttri.getMidpoint( _ray.origin );\r\n\ttri.getNormal( _ray.direction );\r\n\r\n\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\r\n\tconst hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\r\n\treturn hitBackSide ? BACK_SIDE : FRONT_SIDE;\r\n\r\n}\r\n\r\nexport function getHitSideWithCoplanarCheck( tri, bvh ) {\r\n\r\n\t// random function that returns [ - 0.5, 0.5 ];\r\n\tfunction rand() {\r\n\r\n\t\treturn Math.random() - 0.5;\r\n\r\n\t}\r\n\r\n\t// get the ray the check the triangle for\r\n\ttri.getNormal( _normal );\r\n\t_ray.direction.copy( _normal );\r\n\ttri.getMidpoint( _ray.origin );\r\n\r\n\tconst total = 3;\r\n\tlet count = 0;\r\n\tlet minDistance = Infinity;\r\n\tfor ( let i = 0; i < total; i ++ ) {\r\n\r\n\t\t// jitter the ray slightly\r\n\t\t_ray.direction.x += rand() * JITTER_EPSILON;\r\n\t\t_ray.direction.y += rand() * JITTER_EPSILON;\r\n\t\t_ray.direction.z += rand() * JITTER_EPSILON;\r\n\r\n\t\t// and invert it so we can account for floating point error by checking both directions\r\n\t\t// to catch coplanar distances\r\n\t\t_ray.direction.multiplyScalar( - 1 );\r\n\r\n\t\t// check if the ray hit the backside\r\n\t\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\r\n\t\tlet hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\r\n\t\tif ( hitBackSide ) {\r\n\r\n\t\t\tcount ++;\r\n\r\n\t\t}\r\n\r\n\t\tif ( hit !== null ) {\r\n\r\n\t\t\tminDistance = Math.min( minDistance, hit.distance );\r\n\r\n\t\t}\r\n\r\n\t\t// if we're right up against another face then we're coplanar\r\n\t\tif ( minDistance <= OFFSET_EPSILON ) {\r\n\r\n\t\t\treturn hit.face.normal.dot( _normal ) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;\r\n\r\n\t\t}\r\n\r\n\t\t// if our current casts meet our requirements then early out\r\n\t\tif ( count / total > 0.5 || ( i - count + 1 ) / total > 0.5 ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;\r\n\r\n}\r\n\r\n// returns the intersected triangles and returns objects mapping triangle indices to\r\n// the other triangles intersected\r\nexport function collectIntersectingTriangles( a, b ) {\r\n\r\n\tconst aIntersections = new IntersectionMap();\r\n\tconst bIntersections = new IntersectionMap();\r\n\r\n\t_matrix\r\n\t\t.copy( a.matrixWorld )\r\n\t\t.invert()\r\n\t\t.multiply( b.matrixWorld );\r\n\r\n\ta.geometry.boundsTree.bvhcast( b.geometry.boundsTree, _matrix, {\r\n\r\n\t\tintersectsTriangles( triangleA, triangleB, ia, ib ) {\r\n\r\n\t\t\tif ( ! isTriDegenerate( triangleA ) && ! isTriDegenerate( triangleB ) ) {\r\n\r\n\t\t\t\t// due to floating point error it's possible that we can have two overlapping, coplanar triangles\r\n\t\t\t\t// that are a _tiny_ fraction of a value away from each other. If we find that case then check the\r\n\t\t\t\t// distance between triangles and if it's small enough consider them intersecting.\r\n\t\t\t\tlet intersected = triangleA.intersectsTriangle( triangleB, _edge, true );\r\n\t\t\t\tif ( ! intersected ) {\r\n\r\n\t\t\t\t\tconst pa = triangleA.plane;\r\n\t\t\t\t\tconst pb = triangleB.plane;\r\n\t\t\t\t\tconst na = pa.normal;\r\n\t\t\t\t\tconst nb = pb.normal;\r\n\r\n\t\t\t\t\tif ( na.dot( nb ) === 1 && Math.abs( pa.constant - pb.constant ) < FLOATING_COPLANAR_EPSILON ) {\r\n\r\n\t\t\t\t\t\tintersected = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( intersected ) {\r\n\r\n\t\t\t\t\tlet va = a.geometry.boundsTree.resolveTriangleIndex( ia );\r\n\t\t\t\t\tlet vb = b.geometry.boundsTree.resolveTriangleIndex( ib );\r\n\t\t\t\t\taIntersections.add( va, vb );\r\n\t\t\t\t\tbIntersections.add( vb, va );\r\n\r\n\t\t\t\t\tif ( _debugContext ) {\r\n\r\n\t\t\t\t\t\t_debugContext.addEdge( _edge );\r\n\t\t\t\t\t\t_debugContext.addIntersectingTriangles( ia, triangleA, ib, triangleB );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn { aIntersections, bIntersections };\r\n\r\n}\r\n\r\n// Add the barycentric interpolated values fro the triangle into the new attribute data\r\nexport function appendAttributeFromTriangle(\r\n\ttriIndex,\r\n\tbaryCoordTri,\r\n\tgeometry,\r\n\tmatrixWorld,\r\n\tnormalMatrix,\r\n\tattributeData,\r\n\tinvert = false,\r\n) {\r\n\r\n\tconst attributes = geometry.attributes;\r\n\tconst indexAttr = geometry.index;\r\n\tconst i3 = triIndex * 3;\r\n\tconst i0 = indexAttr.getX( i3 + 0 );\r\n\tconst i1 = indexAttr.getX( i3 + 1 );\r\n\tconst i2 = indexAttr.getX( i3 + 2 );\r\n\r\n\tfor ( const key in attributeData ) {\r\n\r\n\t\t// check if the key we're asking for is in the geometry at all\r\n\t\tconst attr = attributes[ key ];\r\n\t\tconst arr = attributeData[ key ];\r\n\t\tif ( ! ( key in attributes ) ) {\r\n\r\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } not available on geometry.` );\r\n\r\n\t\t}\r\n\r\n\t\t// handle normals and positions specially because they require transforming\r\n\t\t// TODO: handle tangents\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tif ( key === 'position' ) {\r\n\r\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyMatrix4( matrixWorld );\r\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyMatrix4( matrixWorld );\r\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert );\r\n\r\n\t\t} else if ( key === 'normal' ) {\r\n\r\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyNormalMatrix( normalMatrix );\r\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyNormalMatrix( normalMatrix );\r\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\tif ( invert ) {\r\n\r\n\t\t\t\t_tri.a.multiplyScalar( - 1 );\r\n\t\t\t\t_tri.b.multiplyScalar( - 1 );\r\n\t\t\t\t_tri.c.multiplyScalar( - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_vec4a.fromBufferAttribute( attr, i0 );\r\n\t\t\t_vec4b.fromBufferAttribute( attr, i1 );\r\n\t\t\t_vec4c.fromBufferAttribute( attr, i2 );\r\n\r\n\t\t\tpushBarycoordInterpolatedValues( _vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Append all the values of the attributes for the triangle onto the new attribute arrays\r\nexport function appendAttributesFromIndices(\r\n\ti0,\r\n\ti1,\r\n\ti2,\r\n\tattributes,\r\n\tmatrixWorld,\r\n\tnormalMatrix,\r\n\tattributeData,\r\n\tinvert = false,\r\n) {\r\n\r\n\tappendAttributeFromIndex( i0, attributes, matrixWorld, normalMatrix, attributeData, invert );\r\n\tappendAttributeFromIndex( invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert );\r\n\tappendAttributeFromIndex( invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert );\r\n\r\n}\r\n\r\n// Returns the triangle to add when performing an operation\r\nexport function getOperationAction( operation, hitSide, invert = false ) {\r\n\r\n\tswitch ( operation ) {\r\n\r\n\t\tcase ADDITION:\r\n\r\n\t\t\tif ( hitSide === FRONT_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase SUBTRACTION:\r\n\r\n\t\t\tif ( invert ) {\r\n\r\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\r\n\r\n\t\t\t\t\treturn INVERT_TRI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\r\n\r\n\t\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase REVERSE_SUBTRACTION:\r\n\r\n\t\t\tif ( invert ) {\r\n\r\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\r\n\r\n\t\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\r\n\r\n\t\t\t\t\treturn INVERT_TRI;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase DIFFERENCE:\r\n\r\n\t\t\tif ( hitSide === BACK_SIDE ) {\r\n\r\n\t\t\t\treturn INVERT_TRI;\r\n\r\n\t\t\t} else if ( hitSide === FRONT_SIDE ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase INTERSECTION:\r\n\t\t\tif ( hitSide === BACK_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase HOLLOW_SUBTRACTION:\r\n\t\t\tif ( ! invert && ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tcase HOLLOW_INTERSECTION:\r\n\t\t\tif ( ! invert && ( hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED ) ) {\r\n\r\n\t\t\t\treturn ADD_TRI;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tthrow new Error( `Unrecognized CSG operation enum \"${ operation }\".` );\r\n\r\n\t}\r\n\r\n\treturn SKIP_TRI;\r\n\r\n}\r\n\r\n// takes a set of barycentric values in the form of a triangle, a set of vectors, number of components,\r\n// and whether to invert the result and pushes the new values onto the provided attribute array\r\nfunction pushBarycoordInterpolatedValues( v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false ) {\r\n\r\n\t// adds the appropriate number of values for the vector onto the array\r\n\tconst addValues = v => {\r\n\r\n\t\tattrArr.push( v.x );\r\n\t\tif ( itemSize > 1 ) attrArr.push( v.y );\r\n\t\tif ( itemSize > 2 ) attrArr.push( v.z );\r\n\t\tif ( itemSize > 3 ) attrArr.push( v.w );\r\n\r\n\t};\r\n\r\n\t// barycentric interpolate the first component\r\n\t_vec4_0.set( 0, 0, 0, 0 )\r\n\t\t.addScaledVector( v0, baryCoordTri.a.x )\r\n\t\t.addScaledVector( v1, baryCoordTri.a.y )\r\n\t\t.addScaledVector( v2, baryCoordTri.a.z );\r\n\r\n\t_vec4_1.set( 0, 0, 0, 0 )\r\n\t\t.addScaledVector( v0, baryCoordTri.b.x )\r\n\t\t.addScaledVector( v1, baryCoordTri.b.y )\r\n\t\t.addScaledVector( v2, baryCoordTri.b.z );\r\n\r\n\t_vec4_2.set( 0, 0, 0, 0 )\r\n\t\t.addScaledVector( v0, baryCoordTri.c.x )\r\n\t\t.addScaledVector( v1, baryCoordTri.c.y )\r\n\t\t.addScaledVector( v2, baryCoordTri.c.z );\r\n\r\n\tif ( normalize ) {\r\n\r\n\t\t_vec4_0.normalize();\r\n\t\t_vec4_1.normalize();\r\n\t\t_vec4_2.normalize();\r\n\r\n\t}\r\n\r\n\t// if the face is inverted then add the values in an inverted order\r\n\taddValues( _vec4_0 );\r\n\r\n\tif ( invert ) {\r\n\r\n\t\taddValues( _vec4_2 );\r\n\t\taddValues( _vec4_1 );\r\n\r\n\t} else {\r\n\r\n\t\taddValues( _vec4_1 );\r\n\t\taddValues( _vec4_2 );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Adds the values for the given vertex index onto the new attribute arrays\r\nfunction appendAttributeFromIndex(\r\n\tindex,\r\n\tattributes,\r\n\tmatrixWorld,\r\n\tnormalMatrix,\r\n\tattributeData,\r\n\tinvert = false,\r\n) {\r\n\r\n\tfor ( const key in attributeData ) {\r\n\r\n\t\t// check if the key we're asking for is in the geometry at all\r\n\t\tconst attr = attributes[ key ];\r\n\t\tconst arr = attributeData[ key ];\r\n\t\tif ( ! ( key in attributes ) ) {\r\n\r\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } no available on geometry.` );\r\n\r\n\t\t}\r\n\r\n\t\t// specially handle the position and normal attributes because they require transforms\r\n\t\t// TODO: handle tangents\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tif ( key === 'position' ) {\r\n\r\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyMatrix4( matrixWorld );\r\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\r\n\r\n\t\t} else if ( key === 'normal' ) {\r\n\r\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyNormalMatrix( normalMatrix );\r\n\t\t\tif ( invert ) {\r\n\r\n\t\t\t\t_vec3.multiplyScalar( - 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarr.push( attr.getX( index ) );\r\n\t\t\tif ( itemSize > 1 ) arr.push( attr.getY( index ) );\r\n\t\t\tif ( itemSize > 2 ) arr.push( attr.getZ( index ) );\r\n\t\t\tif ( itemSize > 3 ) arr.push( attr.getW( index ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Triangle } from 'three';\r\nimport { setDebugContext } from '../operations/operationsUtils.js';\r\n\r\nclass TriangleIntersectData {\r\n\r\n\tconstructor( tri ) {\r\n\r\n\t\tthis.triangle = new Triangle().copy( tri );\r\n\t\tthis.intersects = {};\r\n\r\n\t}\r\n\r\n\taddTriangle( index, tri ) {\r\n\r\n\t\tthis.intersects[ index ] = new Triangle().copy( tri );\r\n\r\n\t}\r\n\r\n\tgetIntersectArray() {\r\n\r\n\t\tconst array = [];\r\n\t\tconst { intersects } = this;\r\n\t\tfor ( const key in intersects ) {\r\n\r\n\t\t\tarray.push( intersects[ key ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass TriangleIntersectionSets {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.data = {};\r\n\r\n\t}\r\n\r\n\taddTriangleIntersection( ia, triA, ib, triB ) {\r\n\r\n\t\tconst { data } = this;\r\n\t\tif ( ! data[ ia ] ) {\r\n\r\n\t\t\tdata[ ia ] = new TriangleIntersectData( triA );\r\n\r\n\t\t}\r\n\r\n\t\tdata[ ia ].addTriangle( ib, triB );\r\n\r\n\t}\r\n\r\n\tgetTrianglesAsArray( id = null ) {\r\n\r\n\t\tconst { data } = this;\r\n\t\tconst arr = [];\r\n\r\n\t\tif ( id !== null ) {\r\n\r\n\t\t\tif ( id in data ) {\r\n\r\n\t\t\t\tarr.push( data[ id ].triangle );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( const key in data ) {\r\n\r\n\t\t\t\tarr.push( data[ key ].triangle );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn arr;\r\n\r\n\t}\r\n\r\n\tgetTriangleIndices() {\r\n\r\n\t\treturn Object.keys( this.data ).map( i => parseInt( i ) );\r\n\r\n\t}\r\n\r\n\tgetIntersectionIndices( id ) {\r\n\r\n\t\tconst { data } = this;\r\n\t\tif ( ! data[ id ] ) {\r\n\r\n\t\t\treturn [];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn Object.keys( data[ id ].intersects ).map( i => parseInt( i ) );\r\n\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgetIntersectionsAsArray( id = null, id2 = null ) {\r\n\r\n\t\tconst { data } = this;\r\n\t\tconst triSet = new Set();\r\n\t\tconst arr = [];\r\n\r\n\t\tconst addTriangles = key => {\r\n\r\n\t\t\tif ( ! data[ key ] ) return;\r\n\r\n\t\t\tif ( id2 !== null ) {\r\n\r\n\t\t\t\tif ( data[ key ].intersects[ id2 ] ) {\r\n\r\n\t\t\t\t\tarr.push( data[ key ].intersects[ id2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst intersects = data[ key ].intersects;\r\n\t\t\t\tfor ( const key2 in intersects ) {\r\n\r\n\t\t\t\t\tif ( ! triSet.has( key2 ) ) {\r\n\r\n\t\t\t\t\t\ttriSet.add( key2 );\r\n\t\t\t\t\t\tarr.push( intersects[ key2 ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tif ( id !== null ) {\r\n\r\n\t\t\taddTriangles( id );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( const key in data ) {\r\n\r\n\t\t\t\taddTriangles( key );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn arr;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.data = {};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class OperationDebugData {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.enabled = false;\r\n\t\tthis.triangleIntersectsA = new TriangleIntersectionSets();\r\n\t\tthis.triangleIntersectsB = new TriangleIntersectionSets();\r\n\t\tthis.intersectionEdges = [];\r\n\r\n\t}\r\n\r\n\taddIntersectingTriangles( ia, triA, ib, triB ) {\r\n\r\n\t\tconst { triangleIntersectsA, triangleIntersectsB } = this;\r\n\t\ttriangleIntersectsA.addTriangleIntersection( ia, triA, ib, triB );\r\n\t\ttriangleIntersectsB.addTriangleIntersection( ib, triB, ia, triA );\r\n\r\n\t}\r\n\r\n\taddEdge( edge ) {\r\n\r\n\t\tthis.intersectionEdges.push( edge.clone() );\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.triangleIntersectsA.reset();\r\n\t\tthis.triangleIntersectsB.reset();\r\n\t\tthis.intersectionEdges = [];\r\n\r\n\t}\r\n\r\n\tinit() {\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\tthis.reset();\r\n\t\t\tsetDebugContext( this );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcomplete() {\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\tsetDebugContext( null );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Matrix4, Matrix3, Triangle } from 'three';\r\nimport {\r\n\tgetHitSideWithCoplanarCheck,\r\n\tgetHitSide,\r\n\tcollectIntersectingTriangles,\r\n\tappendAttributeFromTriangle,\r\n\tappendAttributesFromIndices,\r\n\tgetOperationAction,\r\n\tSKIP_TRI, INVERT_TRI,\r\n} from './operationsUtils.js';\r\nimport { getTriCount } from '../utils/geometryUtils.js';\r\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\r\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\r\n\r\nconst _matrix = new Matrix4();\r\nconst _normalMatrix = new Matrix3();\r\nconst _triA = new Triangle();\r\nconst _triB = new Triangle();\r\nconst _tri = new Triangle();\r\nconst _barycoordTri = new Triangle();\r\nconst _attr = [];\r\nconst _actions = [];\r\n\r\nfunction getFirstIdFromSet( set ) {\r\n\r\n\tfor ( const id of set ) return id;\r\n\r\n}\r\n\r\n// runs the given operation against a and b using the splitter and appending data to the\r\n// attributeData object.\r\nexport function performOperation(\r\n\ta,\r\n\tb,\r\n\toperations,\r\n\tsplitter,\r\n\tattributeData,\r\n\toptions = {},\r\n) {\r\n\r\n\tconst { useGroups = true } = options;\r\n\tconst { aIntersections, bIntersections } = collectIntersectingTriangles( a, b );\r\n\r\n\tconst resultGroups = [];\r\n\tlet resultMaterials = null;\r\n\r\n\tlet groupOffset;\r\n\tgroupOffset = useGroups ? 0 : - 1;\r\n\tperformSplitTriangleOperations( a, b, aIntersections, operations, false, splitter, attributeData, groupOffset );\r\n\tperformWholeTriangleOperations( a, b, aIntersections, operations, false, attributeData, groupOffset );\r\n\r\n\t// find whether the set of operations contains a non-hollow operations. If it does then we need\r\n\t// to perform the second set of triangle additions\r\n\tconst nonHollow = operations\r\n\t\t.findIndex( op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION ) !== - 1;\r\n\r\n\tif ( nonHollow ) {\r\n\r\n\t\tgroupOffset = useGroups ? a.geometry.groups.length || 1 : - 1;\r\n\t\tperformSplitTriangleOperations( b, a, bIntersections, operations, true, splitter, attributeData, groupOffset );\r\n\t\tperformWholeTriangleOperations( b, a, bIntersections, operations, true, attributeData, groupOffset );\r\n\r\n\t}\r\n\r\n\t_attr.length = 0;\r\n\t_actions.length = 0;\r\n\r\n\treturn {\r\n\t\tgroups: resultGroups,\r\n\t\tmaterials: resultMaterials\r\n\t};\r\n\r\n}\r\n\r\n// perform triangle splitting and CSG operations on the set of split triangles\r\nfunction performSplitTriangleOperations(\r\n\ta,\r\n\tb,\r\n\tintersectionMap,\r\n\toperations,\r\n\tinvert,\r\n\tsplitter,\r\n\tattributeData,\r\n\tgroupOffset = 0,\r\n) {\r\n\r\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\r\n\r\n\t// transforms into the local frame of matrix b\r\n\t_matrix\r\n\t\t.copy( b.matrixWorld )\r\n\t\t.invert()\r\n\t\t.multiply( a.matrixWorld );\r\n\r\n\t_normalMatrix\r\n\t\t.getNormalMatrix( a.matrixWorld )\r\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\r\n\r\n\tconst groupIndices = a.geometry.groupIndices;\r\n\tconst aIndex = a.geometry.index;\r\n\tconst aPosition = a.geometry.attributes.position;\r\n\r\n\tconst bBVH = b.geometry.boundsTree;\r\n\tconst bIndex = b.geometry.index;\r\n\tconst bPosition = b.geometry.attributes.position;\r\n\tconst splitIds = intersectionMap.ids;\r\n\tconst intersectionSet = intersectionMap.intersectionSet;\r\n\r\n\t// iterate over all split triangle indices\r\n\tfor ( let i = 0, l = splitIds.length; i < l; i ++ ) {\r\n\r\n\t\tconst ia = splitIds[ i ];\r\n\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ ia ] + groupOffset;\r\n\r\n\t\t// get the triangle in the geometry B local frame\r\n\t\tconst ia3 = 3 * ia;\r\n\t\tconst ia0 = aIndex.getX( ia3 + 0 );\r\n\t\tconst ia1 = aIndex.getX( ia3 + 1 );\r\n\t\tconst ia2 = aIndex.getX( ia3 + 2 );\r\n\t\t_triA.a.fromBufferAttribute( aPosition, ia0 ).applyMatrix4( _matrix );\r\n\t\t_triA.b.fromBufferAttribute( aPosition, ia1 ).applyMatrix4( _matrix );\r\n\t\t_triA.c.fromBufferAttribute( aPosition, ia2 ).applyMatrix4( _matrix );\r\n\r\n\t\t// initialize the splitter with the triangle from geometry A\r\n\t\tsplitter.reset();\r\n\t\tsplitter.initialize( _triA );\r\n\r\n\t\t// split the triangle with the intersecting triangles from B\r\n\t\tconst intersectingIndices = intersectionSet[ ia ];\r\n\t\tfor ( let ib = 0, l = intersectingIndices.length; ib < l; ib ++ ) {\r\n\r\n\t\t\tconst ib3 = 3 * intersectingIndices[ ib ];\r\n\t\t\tconst ib0 = bIndex.getX( ib3 + 0 );\r\n\t\t\tconst ib1 = bIndex.getX( ib3 + 1 );\r\n\t\t\tconst ib2 = bIndex.getX( ib3 + 2 );\r\n\t\t\t_triB.a.fromBufferAttribute( bPosition, ib0 );\r\n\t\t\t_triB.b.fromBufferAttribute( bPosition, ib1 );\r\n\t\t\t_triB.c.fromBufferAttribute( bPosition, ib2 );\r\n\t\t\tsplitter.splitByTriangle( _triB );\r\n\r\n\t\t}\r\n\r\n\t\t// for all triangles in the split result\r\n\t\tconst triangles = splitter.triangles;\r\n\t\tfor ( let ib = 0, l = triangles.length; ib < l; ib ++ ) {\r\n\r\n\t\t\t// get the barycentric coordinates of the clipped triangle to add\r\n\t\t\tconst clippedTri = triangles[ ib ];\r\n\r\n\t\t\t// try to use the side derived from the clipping but if it turns out to be\r\n\t\t\t// uncertain then fall back to the raycasting approach\r\n\t\t\tconst hitSide = splitter.coplanarTriangleUsed ?\r\n\t\t\t\tgetHitSideWithCoplanarCheck( clippedTri, bBVH ) :\r\n\t\t\t\tgetHitSide( clippedTri, bBVH );\r\n\r\n\t\t\t_attr.length = 0;\r\n\t\t\t_actions.length = 0;\r\n\t\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\r\n\r\n\t\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\r\n\t\t\t\tif ( op !== SKIP_TRI ) {\r\n\r\n\t\t\t\t\t_actions.push( op );\r\n\t\t\t\t\t_attr.push( attributeData[ o ].getGroupAttrSet( groupIndex ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _attr.length !== 0 ) {\r\n\r\n\t\t\t\t_triA.getBarycoord( clippedTri.a, _barycoordTri.a );\r\n\t\t\t\t_triA.getBarycoord( clippedTri.b, _barycoordTri.b );\r\n\t\t\t\t_triA.getBarycoord( clippedTri.c, _barycoordTri.c );\r\n\r\n\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\r\n\r\n\t\t\t\t\tconst attrSet = _attr[ k ];\r\n\t\t\t\t\tconst action = _actions[ k ];\r\n\t\t\t\t\tconst invertTri = action === INVERT_TRI;\r\n\t\t\t\t\tappendAttributeFromTriangle( ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn splitIds.length;\r\n\r\n}\r\n\r\n// perform CSG operations on the set of whole triangles using a half edge structure\r\n// at the moment this isn't always faster due to overhead of building the half edge structure\r\n// and degraded connectivity due to split triangles.\r\n\r\nfunction performWholeTriangleOperations(\r\n\ta,\r\n\tb,\r\n\tsplitTriSet,\r\n\toperations,\r\n\tinvert,\r\n\tattributeData,\r\n\tgroupOffset = 0,\r\n) {\r\n\r\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\r\n\r\n\t// matrix for transforming into the local frame of geometry b\r\n\t_matrix\r\n\t\t.copy( b.matrixWorld )\r\n\t\t.invert()\r\n\t\t.multiply( a.matrixWorld );\r\n\r\n\t_normalMatrix\r\n\t\t.getNormalMatrix( a.matrixWorld )\r\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\r\n\r\n\tconst bBVH = b.geometry.boundsTree;\r\n\tconst groupIndices = a.geometry.groupIndices;\r\n\tconst aIndex = a.geometry.index;\r\n\tconst aAttributes = a.geometry.attributes;\r\n\tconst aPosition = aAttributes.position;\r\n\r\n\tconst stack = [];\r\n\tconst halfEdges = a.geometry.halfEdges;\r\n\tconst traverseSet = new Set();\r\n\tconst triCount = getTriCount( a.geometry );\r\n\tfor ( let i = 0, l = triCount; i < l; i ++ ) {\r\n\r\n\t\tif ( ! ( i in splitTriSet.intersectionSet ) ) {\r\n\r\n\t\t\ttraverseSet.add( i );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\twhile ( traverseSet.size > 0 ) {\r\n\r\n\t\tconst id = getFirstIdFromSet( traverseSet );\r\n\t\ttraverseSet.delete( id );\r\n\r\n\t\tstack.push( id );\r\n\r\n\t\t// get the vertex indices\r\n\t\tconst i3 = 3 * id;\r\n\t\tconst i0 = aIndex.getX( i3 + 0 );\r\n\t\tconst i1 = aIndex.getX( i3 + 1 );\r\n\t\tconst i2 = aIndex.getX( i3 + 2 );\r\n\r\n\t\t// get the vertex position in the frame of geometry b so we can\r\n\t\t// perform hit testing\r\n\t\t_tri.a.fromBufferAttribute( aPosition, i0 ).applyMatrix4( _matrix );\r\n\t\t_tri.b.fromBufferAttribute( aPosition, i1 ).applyMatrix4( _matrix );\r\n\t\t_tri.c.fromBufferAttribute( aPosition, i2 ).applyMatrix4( _matrix );\r\n\r\n\t\t// get the side and decide if we need to cull the triangle based on the operation\r\n\t\tconst hitSide = getHitSide( _tri, bBVH );\r\n\r\n\t\t_actions.length = 0;\r\n\t\t_attr.length = 0;\r\n\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\r\n\r\n\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\r\n\t\t\tif ( op !== SKIP_TRI ) {\r\n\r\n\t\t\t\t_actions.push( op );\r\n\t\t\t\t_attr.push( attributeData[ o ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\twhile ( stack.length > 0 ) {\r\n\r\n\t\t\tconst currId = stack.pop();\r\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\tconst sid = halfEdges.getSiblingTriangleIndex( currId, i );\r\n\t\t\t\tif ( sid !== - 1 && traverseSet.has( sid ) ) {\r\n\r\n\t\t\t\t\tstack.push( sid );\r\n\t\t\t\t\ttraverseSet.delete( sid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( _attr.length !== 0 ) {\r\n\r\n\t\t\t\tconst i3 = 3 * currId;\r\n\t\t\t\tconst i0 = aIndex.getX( i3 + 0 );\r\n\t\t\t\tconst i1 = aIndex.getX( i3 + 1 );\r\n\t\t\t\tconst i2 = aIndex.getX( i3 + 2 );\r\n\t\t\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ currId ] + groupOffset;\r\n\r\n\t\t\t\t_tri.a.fromBufferAttribute( aPosition, i0 );\r\n\t\t\t\t_tri.b.fromBufferAttribute( aPosition, i1 );\r\n\t\t\t\t_tri.c.fromBufferAttribute( aPosition, i2 );\r\n\t\t\t\tif ( ! isTriDegenerate( _tri ) ) {\r\n\r\n\t\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\r\n\r\n\t\t\t\t\t\tconst action = _actions[ k ];\r\n\t\t\t\t\t\tconst attrSet = _attr[ k ].getGroupAttrSet( groupIndex );\r\n\t\t\t\t\t\tconst invertTri = action === INVERT_TRI;\r\n\t\t\t\t\t\tappendAttributesFromIndices( i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n", "import { BufferAttribute } from 'three';\r\nimport { TriangleSplitter } from './TriangleSplitter.js';\r\nimport { TypedAttributeData } from './TypedAttributeData.js';\r\nimport { OperationDebugData } from './debug/OperationDebugData.js';\r\nimport { performOperation } from './operations/operations.js';\r\nimport { Brush } from './Brush.js';\r\n\r\n// merges groups with common material indices in place\r\nfunction joinGroups( groups ) {\r\n\r\n\tfor ( let i = 0; i < groups.length - 1; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst nextGroup = groups[ i + 1 ];\r\n\t\tif ( group.materialIndex === nextGroup.materialIndex ) {\r\n\r\n\t\t\tconst start = group.start;\r\n\t\t\tconst end = nextGroup.start + nextGroup.count;\r\n\t\t\tnextGroup.start = start;\r\n\t\t\tnextGroup.count = end - start;\r\n\r\n\t\t\tgroups.splice( i, 1 );\r\n\t\t\ti --;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// initialize the target geometry and attribute data to be based on\r\n// the given reference geometry\r\nfunction prepareAttributesData( referenceGeometry, targetGeometry, attributeData, relevantAttributes ) {\r\n\r\n\tattributeData.clear();\r\n\r\n\t// initialize and clear unused data from the attribute buffers and vice versa\r\n\tconst aAttributes = referenceGeometry.attributes;\r\n\tfor ( let i = 0, l = relevantAttributes.length; i < l; i ++ ) {\r\n\r\n\t\tconst key = relevantAttributes[ i ];\r\n\t\tconst aAttr = aAttributes[ key ];\r\n\t\tattributeData.initializeArray( key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized );\r\n\r\n\t}\r\n\r\n\tfor ( const key in attributeData.attributes ) {\r\n\r\n\t\tif ( ! relevantAttributes.includes( key ) ) {\r\n\r\n\t\t\tattributeData.delete( key );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( const key in targetGeometry.attributes ) {\r\n\r\n\t\tif ( ! relevantAttributes.includes( key ) ) {\r\n\r\n\t\t\ttargetGeometry.deleteAttribute( key );\r\n\t\t\ttargetGeometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Assigns the given tracked attribute data to the geometry and returns whether the\r\n// geometry needs to be disposed of.\r\nfunction assignBufferData( geometry, attributeData, groupOrder ) {\r\n\r\n\tlet needsDisposal = false;\r\n\tlet drawRange = - 1;\r\n\r\n\t// set the data\r\n\tconst attributes = geometry.attributes;\r\n\tconst referenceAttrSet = attributeData.groupAttributes[ 0 ];\r\n\tfor ( const key in referenceAttrSet ) {\r\n\r\n\t\tconst requiredLength = attributeData.getTotalLength( key );\r\n\t\tconst type = attributeData.getType( key );\r\n\t\tconst itemSize = attributeData.getItemSize( key );\r\n\t\tconst normalized = attributeData.getNormalized( key );\r\n\t\tlet geoAttr = attributes[ key ];\r\n\t\tif ( ! geoAttr || geoAttr.array.length < requiredLength ) {\r\n\r\n\t\t\t// create the attribute if it doesn't exist yet\r\n\t\t\tgeoAttr = new BufferAttribute( new type( requiredLength ), itemSize, normalized );\r\n\t\t\tgeometry.setAttribute( key, geoAttr );\r\n\t\t\tneedsDisposal = true;\r\n\r\n\t\t}\r\n\r\n\t\t// assign the data to the geometry attribute buffers in the provided order\r\n\t\t// of the groups list\r\n\t\tlet offset = 0;\r\n\t\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\r\n\r\n\t\t\tconst index = groupOrder[ i ].index;\r\n\t\t\tconst { array, type, length } = attributeData.groupAttributes[ index ][ key ];\r\n\t\t\tconst trimmedArray = new type( array.buffer, 0, length );\r\n\t\t\tgeoAttr.array.set( trimmedArray, offset );\r\n\t\t\toffset += trimmedArray.length;\r\n\r\n\t\t}\r\n\r\n\t\tgeoAttr.needsUpdate = true;\r\n\t\tdrawRange = requiredLength / geoAttr.itemSize;\r\n\r\n\t}\r\n\r\n\t// remove or update the index appropriately\r\n\tif ( geometry.index ) {\r\n\r\n\t\tconst indexArray = geometry.index.array;\r\n\t\tif ( indexArray.length < drawRange ) {\r\n\r\n\t\t\tgeometry.index = null;\r\n\t\t\tneedsDisposal = true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tindexArray[ i ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// initialize the groups\r\n\tlet groupOffset = 0;\r\n\tgeometry.clearGroups();\r\n\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\r\n\r\n\t\tconst { index, materialIndex } = groupOrder[ i ];\r\n\t\tconst vertCount = attributeData.getCount( index );\r\n\t\tif ( vertCount !== 0 ) {\r\n\r\n\t\t\tgeometry.addGroup( groupOffset, vertCount, materialIndex );\r\n\t\t\tgroupOffset += vertCount;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// update the draw range\r\n\tgeometry.setDrawRange( 0, drawRange );\r\n\r\n\t// remove the bounds tree if it exists because its now out of date\r\n\t// TODO: can we have this dispose in the same way that a brush does?\r\n\t// TODO: why are half edges and group indices not removed here?\r\n\tgeometry.boundsTree = null;\r\n\r\n\tif ( needsDisposal ) {\r\n\r\n\t\tgeometry.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Returns the list of materials used for the given set of groups\r\nfunction getMaterialList( groups, materials ) {\r\n\r\n\tlet result = materials;\r\n\tif ( ! Array.isArray( materials ) ) {\r\n\r\n\t\tresult = [];\r\n\t\tgroups.forEach( g => {\r\n\r\n\t\t\tresult[ g.materialIndex ] = materials;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n// Utility class for performing CSG operations\r\nexport class Evaluator {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.triangleSplitter = new TriangleSplitter();\r\n\t\tthis.attributeData = [];\r\n\t\tthis.attributes = [ 'position', 'uv', 'normal' ];\r\n\t\tthis.useGroups = true;\r\n\t\tthis.consolidateGroups = true;\r\n\t\tthis.debug = new OperationDebugData();\r\n\r\n\t}\r\n\r\n\tgetGroupRanges( geometry ) {\r\n\r\n\t\treturn ! this.useGroups || geometry.groups.length === 0 ?\r\n\t\t\t[ { start: 0, count: Infinity, materialIndex: 0 } ] :\r\n\t\t\tgeometry.groups.map( group => ( { ...group } ) );\r\n\r\n\t}\r\n\r\n\tevaluate( a, b, operations, targetBrushes = new Brush() ) {\r\n\r\n\t\tlet wasArray = true;\r\n\t\tif ( ! Array.isArray( operations ) ) {\r\n\r\n\t\t\toperations = [ operations ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! Array.isArray( targetBrushes ) ) {\r\n\r\n\t\t\ttargetBrushes = [ targetBrushes ];\r\n\t\t\twasArray = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( targetBrushes.length !== operations.length ) {\r\n\r\n\t\t\tthrow new Error( 'Evaluator: operations and target array passed as different sizes.' );\r\n\r\n\t\t}\r\n\r\n\t\ta.prepareGeometry();\r\n\t\tb.prepareGeometry();\r\n\r\n\t\tconst {\r\n\t\t\ttriangleSplitter,\r\n\t\t\tattributeData,\r\n\t\t\tattributes,\r\n\t\t\tuseGroups,\r\n\t\t\tconsolidateGroups,\r\n\t\t\tdebug,\r\n\t\t} = this;\r\n\r\n\t\t// expand the attribute data array to the necessary size\r\n\t\twhile ( attributeData.length < targetBrushes.length ) {\r\n\r\n\t\t\tattributeData.push( new TypedAttributeData() );\r\n\r\n\t\t}\r\n\r\n\t\t// prepare the attribute data buffer information\r\n\t\ttargetBrushes.forEach( ( brush, i ) => {\r\n\r\n\t\t\tprepareAttributesData( a.geometry, brush.geometry, attributeData[ i ], attributes );\r\n\r\n\t\t} );\r\n\r\n\t\t// run the operation to fill the list of attribute data\r\n\t\tdebug.init();\r\n\t\tperformOperation( a, b, operations, triangleSplitter, attributeData, { useGroups } );\r\n\t\tdebug.complete();\r\n\r\n\t\t// get the materials and group ranges\r\n\t\tconst aGroups = this.getGroupRanges( a.geometry );\r\n\t\tconst aMaterials = getMaterialList( aGroups, a.material );\r\n\r\n\t\tconst bGroups = this.getGroupRanges( b.geometry );\r\n\t\tconst bMaterials = getMaterialList( bGroups, b.material );\r\n\t\tbGroups.forEach( g => g.materialIndex += aMaterials.length );\r\n\r\n\t\tlet groups = [ ...aGroups, ...bGroups ]\r\n\t\t\t.map( ( group, index ) => ( { ...group, index } ) );\r\n\r\n\t\t// generate the minimum set of materials needed for the list of groups and adjust the groups\r\n\t\t// if they're needed\r\n\t\tif ( useGroups ) {\r\n\r\n\t\t\tconst allMaterials = [ ...aMaterials, ...bMaterials ];\r\n\t\t\tif ( consolidateGroups ) {\r\n\r\n\t\t\t\tgroups = groups\r\n\t\t\t\t\t.map( group => {\r\n\r\n\t\t\t\t\t\tconst mat = allMaterials[ group.materialIndex ];\r\n\t\t\t\t\t\tgroup.materialIndex = allMaterials.indexOf( mat );\r\n\t\t\t\t\t\treturn group;\r\n\r\n\t\t\t\t\t} )\r\n\t\t\t\t\t.sort( ( a, b ) => {\r\n\r\n\t\t\t\t\t\treturn a.materialIndex - b.materialIndex;\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// create a map from old to new index and remove materials that aren't used\r\n\t\t\tconst finalMaterials = [];\r\n\t\t\tfor ( let i = 0, l = allMaterials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tlet foundGroup = false;\r\n\t\t\t\tfor ( let g = 0, lg = groups.length; g < lg; g ++ ) {\r\n\r\n\t\t\t\t\tconst group = groups[ g ];\r\n\t\t\t\t\tif ( group.materialIndex === i ) {\r\n\r\n\t\t\t\t\t\tfoundGroup = true;\r\n\t\t\t\t\t\tgroup.materialIndex = finalMaterials.length;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( foundGroup ) {\r\n\r\n\t\t\t\t\tfinalMaterials.push( allMaterials[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetBrushes.forEach( tb => {\r\n\r\n\t\t\t\ttb.material = finalMaterials;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgroups = [ { start: 0, count: Infinity, index: 0, materialIndex: 0 } ];\r\n\t\t\ttargetBrushes.forEach( tb => {\r\n\r\n\t\t\t\ttb.material = aMaterials[ 0 ];\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\t// apply groups and attribute data to the geometry\r\n\t\ttargetBrushes.forEach( ( brush, i ) => {\r\n\r\n\t\t\tconst targetGeometry = brush.geometry;\r\n\t\t\tassignBufferData( targetGeometry, attributeData[ i ], groups );\r\n\t\t\tif ( consolidateGroups ) {\r\n\r\n\t\t\t\tjoinGroups( targetGeometry.groups );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn wasArray ? targetBrushes : targetBrushes[ 0 ];\r\n\r\n\t}\r\n\r\n\t// TODO: fix\r\n\tevaluateHierarchy( root, target = new Brush() ) {\r\n\r\n\t\troot.updateMatrixWorld( true );\r\n\r\n\t\tconst flatTraverse = ( obj, cb ) => {\r\n\r\n\t\t\tconst children = obj.children;\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst child = children[ i ];\r\n\t\t\t\tif ( child.isOperationGroup ) {\r\n\r\n\t\t\t\t\tflatTraverse( child, cb );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcb( child );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\t\tconst traverse = brush => {\r\n\r\n\t\t\tconst children = brush.children;\r\n\t\t\tlet didChange = false;\r\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst child = children[ i ];\r\n\t\t\t\tdidChange = traverse( child ) || didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isDirty = brush.isDirty();\r\n\t\t\tif ( isDirty ) {\r\n\r\n\t\t\t\tbrush.markUpdated();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( didChange && ! brush.isOperationGroup ) {\r\n\r\n\t\t\t\tlet result;\r\n\t\t\t\tflatTraverse( brush, child => {\r\n\r\n\t\t\t\t\tif ( ! result ) {\r\n\r\n\t\t\t\t\t\tresult = this.evaluate( brush, child, child.operation );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tresult = this.evaluate( result, child, child.operation );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tbrush._cachedGeometry = result.geometry;\r\n\t\t\t\tbrush._cachedMaterials = result.material;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn didChange || isDirty;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\ttraverse( root );\r\n\r\n\t\ttarget.geometry = root._cachedGeometry;\r\n\t\ttarget.material = root._cachedMaterials;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.triangleSplitter.reset();\r\n\r\n\t}\r\n\r\n}\r\n", "import { BufferGeometry } from 'three';\r\nimport { Brush } from '../Brush.js';\r\nimport { ADDITION } from '../constants.js';\r\n\r\nexport class Operation extends Brush {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.isOperation = true;\r\n\t\tthis.operation = ADDITION;\r\n\r\n\t\tthis._cachedGeometry = new BufferGeometry();\r\n\t\tthis._cachedMaterials = null;\r\n\t\tthis._previousOperation = null;\r\n\r\n\t}\r\n\r\n\tmarkUpdated() {\r\n\r\n\t\tsuper.markUpdated();\r\n\t\tthis._previousOperation = this.operation;\r\n\r\n\t}\r\n\r\n\tisDirty() {\r\n\r\n\t\treturn this.operation !== this._previousOperation || super.isDirty();\r\n\r\n\t}\r\n\r\n\tinsertBefore( brush ) {\r\n\r\n\t\tconst parent = this.parent;\r\n\t\tconst index = parent.children.indexOf( this );\r\n\t\tparent.children.splice( index, 0, brush );\r\n\r\n\t}\r\n\r\n\tinsertAfter( brush ) {\r\n\r\n\t\tconst parent = this.parent;\r\n\t\tconst index = parent.children.indexOf( this );\r\n\t\tparent.children.splice( index + 1, 0, brush );\r\n\r\n\t}\r\n\r\n}\r\n", "import { Group, Matrix4 } from 'three';\r\n\r\nexport class OperationGroup extends Group {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis.isOperationGroup = true;\r\n\t\tthis._previousMatrix = new Matrix4();\r\n\r\n\t}\r\n\r\n\tmarkUpdated() {\r\n\r\n\t\tthis._previousMatrix.copy( this.matrix );\r\n\r\n\t}\r\n\r\n\tisDirty() {\r\n\r\n\t\tconst { matrix, _previousMatrix } = this;\r\n\t\tconst el1 = matrix.elements;\r\n\t\tconst el2 = _previousMatrix.elements;\r\n\t\tfor ( let i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n", "import { Color } from 'three';\r\n\r\nfunction addWorldPosition( shader ) {\r\n\r\n\tif ( /varying\\s+vec3\\s+wPosition/.test( shader.vertexShader ) ) return;\r\n\r\n\tshader.vertexShader = `\r\n\t\t\tvarying vec3 wPosition;\r\n\t\t\t${shader.vertexShader}\r\n\t\t`.replace(\r\n\t\t/#include <displacementmap_vertex>/,\r\n\t\tv =>\r\n\t\t\t`${v}\r\n\t\t\t\twPosition = (modelMatrix * vec4( transformed, 1.0 )).xyz;\r\n\t\t\t\t`,\r\n\t);\r\n\r\n\tshader.fragmentShader = `\r\n\t\tvarying vec3 wPosition;\r\n\t\t${shader.fragmentShader}\r\n\t\t`;\r\n\r\n\treturn shader;\r\n\r\n}\r\n\r\nexport function csgGridShaderMixin( shader ) {\r\n\r\n\tshader.uniforms = {\r\n\t\t...shader.uniforms,\r\n\t\tcheckerboardColor: { value: new Color( 0x111111 ) }\r\n\t};\r\n\r\n\taddWorldPosition( shader );\r\n\r\n\tshader.defines = { CSG_GRID: 1 };\r\n\r\n\tshader.fragmentShader = shader.fragmentShader.replace(\r\n\t\t/#include <common>/,\r\n\t\tv =>\r\n\t\t/* glsl */`\r\n\t\t\t${v}\r\n\r\n\t\t\tuniform vec3 checkerboardColor;\r\n\t\t\tfloat getCheckerboard( vec2 p, float scale ) {\r\n\r\n\t\t\t\tp /= scale;\r\n\t\t\t\tp += vec2( 0.5 );\r\n\r\n\t\t\t\tvec2 line = mod( p, 2.0 ) - vec2( 1.0 );\r\n\t\t\t\tline = abs( line );\r\n\r\n\t\t\t\tvec2 pWidth = fwidth( line );\r\n\t\t\t\tvec2 value = smoothstep( 0.5 - pWidth / 2.0, 0.5 + pWidth / 2.0, line );\r\n\t\t\t\tfloat result = value.x * value.y + ( 1.0 - value.x ) * ( 1.0 - value.y );\r\n\r\n\t\t\t\treturn result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat getGrid( vec2 p, float scale, float thickness ) {\r\n\r\n\t\t\t\tp /= 0.5 * scale;\r\n\r\n\t\t\t\tvec2 stride = mod( p, 2.0 ) - vec2( 1.0 );\r\n\t\t\t\tstride = abs( stride );\r\n\r\n\t\t\t\tvec2 pWidth = fwidth( p );\r\n\t\t\t\tvec2 line = smoothstep( 1.0 - pWidth / 2.0, 1.0 + pWidth / 2.0, stride + thickness * pWidth );\r\n\r\n\t\t\t\treturn max( line.x, line.y );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec3 getFaceColor( vec2 p, vec3 color ) {\r\n\r\n\t\t\t\tfloat checkLarge = getCheckerboard( p, 1.0 );\r\n\t\t\t\tfloat checkSmall = abs( getCheckerboard( p, 0.1 ) );\r\n\t\t\t\tfloat lines = getGrid( p, 10.0, 1.0 );\r\n\r\n\t\t\t\tvec3 checkColor = mix(\r\n\t\t\t\t\tvec3( 0.7 ) * color,\r\n\t\t\t\t\tvec3( 1.0 ) * color,\r\n\t\t\t\t\tcheckSmall * 0.4 + checkLarge * 0.6\r\n\t\t\t\t);\r\n\r\n\t\t\t\tvec3 gridColor = vec3( 1.0 );\r\n\r\n\t\t\t\treturn mix( checkColor, gridColor, lines );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloat angleBetween( vec3 a, vec3 b ) {\r\n\r\n\t\t\t\treturn acos( abs( dot( a, b ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec3 planeProject( vec3 norm, vec3 other ) {\r\n\r\n\t\t\t\tfloat d = dot( norm, other );\r\n\t\t\t\treturn normalize( other - norm * d );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvec3 getBlendFactors( vec3 norm ) {\r\n\r\n\t\t\t\tvec3 xVec = vec3( 1.0, 0.0, 0.0 );\r\n\t\t\t\tvec3 yVec = vec3( 0.0, 1.0, 0.0 );\r\n\t\t\t\tvec3 zVec = vec3( 0.0, 0.0, 1.0 );\r\n\r\n\t\t\t\tvec3 projX = planeProject( xVec, norm );\r\n\t\t\t\tvec3 projY = planeProject( yVec, norm );\r\n\t\t\t\tvec3 projZ = planeProject( zVec, norm );\r\n\r\n\t\t\t\tfloat xAngle = max(\r\n\t\t\t\t\tangleBetween( xVec, projY ),\r\n\t\t\t\t\tangleBetween( xVec, projZ )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tfloat yAngle = max(\r\n\t\t\t\t\tangleBetween( yVec, projX ),\r\n\t\t\t\t\tangleBetween( yVec, projZ )\r\n\t\t\t\t);\r\n\r\n\t\t\t\tfloat zAngle = max(\r\n\t\t\t\t\tangleBetween( zVec, projX ),\r\n\t\t\t\t\tangleBetween( zVec, projY )\r\n\t\t\t\t);\r\n\r\n\t\t\t\treturn vec3( xAngle, yAngle, zAngle ) / ( 0.5 * PI );\r\n\r\n\t\t\t}\r\n\t\t` ).replace(\r\n\t\t/#include <normal_fragment_maps>/,\r\n\t\tv =>\r\n\t\t/* glsl */`${v}\r\n\t\t\t\t#if CSG_GRID\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\r\n\r\n\t\t\t\t\tfloat yCont = abs( dot( vec3( 0.0, 1.0, 0.0 ), worldNormal ) );\r\n\t\t\t\t\tfloat zCont = abs( dot( vec3( 0.0, 0.0, 1.0 ), worldNormal ) );\r\n\t\t\t\t\tfloat xCont = abs( dot( vec3( 1.0, 0.0, 0.0 ), worldNormal ) );\r\n\r\n\t\t\t\t\tvec3 factors = getBlendFactors( worldNormal );\r\n\t\t\t\t\tfactors = smoothstep( vec3( 0.475 ), vec3( 0.525 ), vec3( 1.0 ) - factors );\r\n\r\n\t\t\t\t\tfloat weight = factors.x + factors.y + factors.z;\r\n\t\t\t\t\tfactors /= weight;\r\n\r\n\t\t\t\t\tvec3 color =\r\n\t\t\t\t\t\tgetFaceColor( wPosition.yz, diffuseColor.rgb ) * factors.x +\r\n\t\t\t\t\t\tgetFaceColor( wPosition.xz, diffuseColor.rgb ) * factors.y +\r\n\t\t\t\t\t\tgetFaceColor( wPosition.xy, diffuseColor.rgb ) * factors.z;\r\n\r\n\t\t\t\t\tdiffuseColor.rgb = color;\r\n\r\n\t\t\t\t}\r\n\t\t\t\t#endif\r\n\t\t\t\t`,\r\n\t);\r\n\r\n\treturn shader;\r\n\r\n}\r\n", "import { MeshPhongMaterial } from 'three';\r\nimport { csgGridShaderMixin } from './shaderUtils.js';\r\n\r\nexport class GridMaterial extends MeshPhongMaterial {\r\n\r\n\tget enableGrid() {\r\n\r\n\t\treturn Boolean( this._enableGrid );\r\n\r\n\t}\r\n\r\n\tset enableGrid( v ) {\r\n\r\n\t\tif ( this._enableGrid !== v ) {\r\n\r\n\t\t\tthis._enableGrid = v;\r\n\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tthis.enableGrid = true;\r\n\r\n\t}\r\n\r\n\tonBeforeCompile( shader ) {\r\n\r\n\t\tcsgGridShaderMixin( shader );\r\n\t\tshader.defines.CSG_GRID = Number( this.enableGrid );\r\n\r\n\t}\r\n\r\n\tcustomProgramCacheKey() {\r\n\r\n\t\treturn this.enableGrid.toString();\r\n\r\n\t}\r\n\r\n}\r\n", "import { BufferAttribute, Color, MathUtils } from 'three';\r\n\r\nexport function getTriangleDefinitions( ...triangles ) {\r\n\r\n\tfunction getVectorDefinition( v ) {\r\n\r\n\t\treturn /* js */`new THREE.Vector3( ${ v.x }, ${ v.y }, ${ v.z } )`;\r\n\r\n\t}\r\n\r\n\treturn triangles.map( t => {\r\n\r\n\t\treturn /* js */`\r\nnew THREE.Triangle(\r\n\t${ getVectorDefinition( t.a ) },\r\n\t${ getVectorDefinition( t.b ) },\r\n\t${ getVectorDefinition( t.c ) },\r\n)\r\n\t\t`.trim();\r\n\r\n\t} );\r\n\r\n}\r\n\r\nexport function logTriangleDefinitions( ...triangles ) {\r\n\r\n\tconsole.log( getTriangleDefinitions( ...triangles ).join( ',\\n' ) );\r\n\r\n}\r\n\r\nexport function generateRandomTriangleColors( geometry ) {\r\n\r\n\tconst position = geometry.attributes.position;\r\n\tconst array = new Float32Array( position.count * 3 );\r\n\r\n\tconst color = new Color();\r\n\tfor ( let i = 0, l = array.length; i < l; i += 9 ) {\r\n\r\n\t\tcolor.setHSL(\r\n\t\t\tMath.random(),\r\n\t\t\tMathUtils.lerp( 0.5, 1.0, Math.random() ),\r\n\t\t\tMathUtils.lerp( 0.5, 0.75, Math.random() ),\r\n\t\t);\r\n\r\n\t\tarray[ i + 0 ] = color.r;\r\n\t\tarray[ i + 1 ] = color.g;\r\n\t\tarray[ i + 2 ] = color.b;\r\n\r\n\t\tarray[ i + 3 ] = color.r;\r\n\t\tarray[ i + 4 ] = color.g;\r\n\t\tarray[ i + 5 ] = color.b;\r\n\r\n\t\tarray[ i + 6 ] = color.r;\r\n\t\tarray[ i + 7 ] = color.g;\r\n\t\tarray[ i + 8 ] = color.b;\r\n\r\n\t}\r\n\r\n\tgeometry.setAttribute( 'color', new BufferAttribute( array, 3 ) );\r\n\r\n}\r\n", "import { Group, Mesh, LineSegments, LineBasicMaterial, MeshPhongMaterial, BufferGeometry, BufferAttribute } from 'three';\r\n\r\nexport class TriangleSetHelper extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this._mesh.material.color;\r\n\r\n\t}\r\n\r\n\tget side() {\r\n\r\n\t\treturn this._mesh.material.side;\r\n\r\n\t}\r\n\r\n\tset side( v ) {\r\n\r\n\t\tthis._mesh.material.side = v;\r\n\r\n\t}\r\n\r\n\tconstructor( triangles = [] ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tconst geometry = new BufferGeometry();\r\n\t\tconst lineGeom = new BufferGeometry();\r\n\t\tthis._mesh = new Mesh( geometry, new MeshPhongMaterial( {\r\n\t\t\tflatShading: true,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.25,\r\n\t\t\tdepthWrite: false,\r\n\t\t} ) );\r\n\t\tthis._lines = new LineSegments( lineGeom, new LineBasicMaterial() );\r\n\t\tthis._mesh.material.color = this._lines.material.color;\r\n\r\n\t\tthis._lines.frustumCulled = false;\r\n\t\tthis._mesh.frustumCulled = false;\r\n\r\n\t\tthis.add( this._lines, this._mesh );\r\n\r\n\t\tthis.setTriangles( triangles );\r\n\r\n\t}\r\n\r\n\tsetTriangles( triangles ) {\r\n\r\n\t\tconst triPositions = new Float32Array( 3 * 3 * triangles.length );\r\n\t\tconst linePositions = new Float32Array( 6 * 3 * triangles.length );\r\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst i9 = 9 * i;\r\n\t\t\tconst i18 = 18 * i;\r\n\t\t\tconst tri = triangles[ i ];\r\n\r\n\t\t\ttri.a.toArray( triPositions, i9 + 0 );\r\n\t\t\ttri.b.toArray( triPositions, i9 + 3 );\r\n\t\t\ttri.c.toArray( triPositions, i9 + 6 );\r\n\r\n\r\n\t\t\ttri.a.toArray( linePositions, i18 + 0 );\r\n\t\t\ttri.b.toArray( linePositions, i18 + 3 );\r\n\r\n\t\t\ttri.b.toArray( linePositions, i18 + 6 );\r\n\t\t\ttri.c.toArray( linePositions, i18 + 9 );\r\n\r\n\t\t\ttri.c.toArray( linePositions, i18 + 12 );\r\n\t\t\ttri.a.toArray( linePositions, i18 + 15 );\r\n\r\n\t\t}\r\n\r\n\t\tthis._mesh.geometry.dispose();\r\n\t\tthis._mesh.geometry.setAttribute( 'position', new BufferAttribute( triPositions, 3 ) );\r\n\r\n\t\tthis._lines.geometry.dispose();\r\n\t\tthis._lines.geometry.setAttribute( 'position', new BufferAttribute( linePositions, 3 ) );\r\n\r\n\t}\r\n\r\n}\r\n", "import { LineSegments } from 'three';\r\n\r\nexport class EdgesHelper extends LineSegments {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.material.color;\r\n\r\n\t}\r\n\r\n\tconstructor( edges = [] ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.frustumCulled = false;\r\n\t\tthis.setEdges( edges );\r\n\r\n\t}\r\n\r\n\tsetEdges( edges ) {\r\n\r\n\t\tconst { geometry } = this;\r\n\t\tconst points = edges.flatMap( e => [ e.start, e.end ] );\r\n\t\tgeometry.dispose();\r\n\t\tgeometry.setFromPoints( points );\r\n\r\n\t}\r\n\r\n}\r\n", "import { InstancedMesh, SphereGeometry, MeshBasicMaterial, Matrix4 } from 'three';\r\n\r\nconst _matrix = new Matrix4();\r\nexport class PointsHelper extends InstancedMesh {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.material.color;\r\n\r\n\t}\r\n\r\n\tconstructor( count = 1000, points = [] ) {\r\n\r\n\t\tsuper( new SphereGeometry( 0.025 ), new MeshBasicMaterial(), count );\r\n\t\tthis.frustumCulled = false;\r\n\t\tthis.setPoints( points );\r\n\r\n\t}\r\n\r\n\tsetPoints( points ) {\r\n\r\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst point = points[ i ];\r\n\t\t\t_matrix.makeTranslation( point.x, point.y, point.z );\r\n\t\t\tthis.setMatrixAt( i, _matrix );\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = points.length;\r\n\r\n\t}\r\n\r\n}\r\n", "import { Line3, Triangle, Vector3, Plane, Ray } from 'three';\r\nimport { EdgesHelper } from './EdgesHelper.js';\r\nimport { getTriCount } from '../core/utils/geometryUtils.js';\r\nimport { toNormalizedRay } from '../core/utils/hashUtils.js';\r\n\r\nconst vertKeys = [ 'a', 'b', 'c' ];\r\nconst _tri1 = new Triangle();\r\nconst _tri2 = new Triangle();\r\nconst _center = new Vector3();\r\nconst _center2 = new Vector3();\r\nconst _projected = new Vector3();\r\nconst _projected2 = new Vector3();\r\nconst _projectedDir = new Vector3();\r\nconst _projectedDir2 = new Vector3();\r\nconst _edgeDir = new Vector3();\r\nconst _edgeDir2 = new Vector3();\r\nconst _vec = new Vector3();\r\nconst _vec2 = new Vector3();\r\nconst _finalPoint = new Vector3();\r\nconst _finalPoint2 = new Vector3();\r\nconst _plane = new Plane();\r\nconst _plane2 = new Plane();\r\nconst _centerPoint = new Vector3();\r\nconst _ray = new Ray();\r\nconst _edge = new Line3();\r\n\r\nfunction getTriangle( geometry, triIndex, target ) {\r\n\r\n\tconst i3 = 3 * triIndex;\r\n\tlet i0 = i3 + 0;\r\n\tlet i1 = i3 + 1;\r\n\tlet i2 = i3 + 2;\r\n\r\n\tconst indexAttr = geometry.index;\r\n\tconst posAttr = geometry.attributes.position;\r\n\tif ( indexAttr ) {\r\n\r\n\t\ti0 = indexAttr.getX( i0 );\r\n\t\ti1 = indexAttr.getX( i1 );\r\n\t\ti2 = indexAttr.getX( i2 );\r\n\r\n\t}\r\n\r\n\ttarget.a.fromBufferAttribute( posAttr, i0 );\r\n\ttarget.b.fromBufferAttribute( posAttr, i1 );\r\n\ttarget.c.fromBufferAttribute( posAttr, i2 );\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\nfunction getOverlapEdge( tri1, e1, tri2, e2, target ) {\r\n\r\n\t// get the two edges\r\n\tconst nextE_0 = ( e1 + 1 ) % 3;\r\n\tconst v0_1 = tri1[ vertKeys[ e1 ] ];\r\n\tconst v1_1 = tri1[ vertKeys[ nextE_0 ] ];\r\n\r\n\tconst nextE_1 = ( e2 + 1 ) % 3;\r\n\tconst v0_2 = tri2[ vertKeys[ e2 ] ];\r\n\tconst v1_2 = tri2[ vertKeys[ nextE_1 ] ];\r\n\r\n\t// get the ray defined by the edges\r\n\ttoNormalizedRay( v0_1, v1_1, _ray );\r\n\r\n\t// get the min and max stride across the rays\r\n\tlet d0_1 = _vec.subVectors( v0_1, _ray.origin ).dot( _ray.direction );\r\n\tlet d1_1 = _vec.subVectors( v1_1, _ray.origin ).dot( _ray.direction );\r\n\tif ( d0_1 > d1_1 ) [ d0_1, d1_1 ] = [ d1_1, d0_1 ];\r\n\r\n\tlet d0_2 = _vec.subVectors( v0_2, _ray.origin ).dot( _ray.direction );\r\n\tlet d1_2 = _vec.subVectors( v1_2, _ray.origin ).dot( _ray.direction );\r\n\tif ( d0_2 > d1_2 ) [ d0_2, d1_2 ] = [ d1_2, d0_2 ];\r\n\r\n\t// get the range of overlap\r\n\tconst final_0 = Math.max( d0_1, d0_2 );\r\n\tconst final_1 = Math.min( d1_1, d1_2 );\r\n\t_ray.at( final_0, target.start );\r\n\t_ray.at( final_1, target.end );\r\n\r\n}\r\n\r\n\r\nexport class HalfEdgeHelper extends EdgesHelper {\r\n\r\n\tconstructor( geometry = null, halfEdges = null ) {\r\n\r\n\t\tsuper();\r\n\t\tthis.straightEdges = false;\r\n\t\tthis.displayDisconnectedEdges = false;\r\n\r\n\t\tif ( geometry && halfEdges ) {\r\n\r\n\t\t\tthis.setHalfEdges( geometry, halfEdges );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetHalfEdges( geometry, halfEdges ) {\r\n\r\n\t\tconst { straightEdges, displayDisconnectedEdges } = this;\r\n\t\tconst edges = [];\r\n\t\tconst offset = geometry.drawRange.start;\r\n\t\tlet triCount = getTriCount( geometry );\r\n\t\tif ( geometry.drawRange.count !== Infinity ) {\r\n\r\n\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( displayDisconnectedEdges ) {\r\n\r\n\t\t\tif ( halfEdges.unmatchedDisjointEdges ) {\r\n\r\n\t\t\t\thalfEdges\r\n\t\t\t\t\t.unmatchedDisjointEdges\r\n\t\t\t\t\t.forEach( ( { forward, reverse, ray } ) => {\r\n\r\n\t\t\t\t\t\t[ ...forward, ...reverse ]\r\n\t\t\t\t\t\t\t.forEach( ( { start, end } ) => {\r\n\r\n\t\t\t\t\t\t\t\tconst edge = new Line3();\r\n\t\t\t\t\t\t\t\tray.at( start, edge.start );\r\n\t\t\t\t\t\t\t\tray.at( end, edge.end );\r\n\t\t\t\t\t\t\t\tedges.push( edge );\r\n\r\n\t\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let triIndex = offset; triIndex < triCount; triIndex ++ ) {\r\n\r\n\t\t\t\t\tgetTriangle( geometry, triIndex, _tri1 );\r\n\t\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\t\t\tconst otherTriIndex = halfEdges.getSiblingTriangleIndex( triIndex, e );\r\n\t\t\t\t\t\tif ( otherTriIndex === - 1 ) {\r\n\r\n\t\t\t\t\t\t\tconst nextE = ( e + 1 ) % 3;\r\n\t\t\t\t\t\t\tconst v0 = _tri1[ vertKeys[ e ] ];\r\n\t\t\t\t\t\t\tconst v1 = _tri1[ vertKeys[ nextE ] ];\r\n\t\t\t\t\t\t\tconst edge = new Line3();\r\n\t\t\t\t\t\t\tedge.start.copy( v0 );\r\n\t\t\t\t\t\t\tedge.end.copy( v1 );\r\n\t\t\t\t\t\t\tedges.push( edge );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( let triIndex = offset; triIndex < triCount; triIndex ++ ) {\r\n\r\n\t\t\t\tgetTriangle( geometry, triIndex, _tri1 );\r\n\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\t\tconst otherTriIndex = halfEdges.getSiblingTriangleIndex( triIndex, e );\r\n\t\t\t\t\tif ( otherTriIndex === - 1 ) {\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// get other triangle\r\n\t\t\t\t\tgetTriangle( geometry, otherTriIndex, _tri2 );\r\n\r\n\t\t\t\t\t// get edge centers\r\n\t\t\t\t\tconst nextE = ( e + 1 ) % 3;\r\n\t\t\t\t\tconst v0 = _tri1[ vertKeys[ e ] ];\r\n\t\t\t\t\tconst v1 = _tri1[ vertKeys[ nextE ] ];\r\n\t\t\t\t\t_centerPoint.lerpVectors( v0, v1, 0.5 );\r\n\t\t\t\t\taddConnectionEdge( _tri1, _tri2, _centerPoint );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( halfEdges.disjointConnections ) {\r\n\r\n\t\t\t\t\tfor ( let e = 0; e < 3; e ++ ) {\r\n\r\n\t\t\t\t\t\tconst disjointTriIndices = halfEdges.getDisjointSiblingTriangleIndices( triIndex, e );\r\n\t\t\t\t\t\tconst disjointEdgeIndices = halfEdges.getDisjointSiblingEdgeIndices( triIndex, e );\r\n\r\n\t\t\t\t\t\tfor ( let i = 0; i < disjointTriIndices.length; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tconst ti = disjointTriIndices[ i ];\r\n\t\t\t\t\t\t\tconst ei = disjointEdgeIndices[ i ];\r\n\r\n\t\t\t\t\t\t\t// get other triangle\r\n\t\t\t\t\t\t\tgetTriangle( geometry, ti, _tri2 );\r\n\r\n\t\t\t\t\t\t\tgetOverlapEdge( _tri1, e, _tri2, ei, _edge );\r\n\r\n\t\t\t\t\t\t\t_centerPoint.lerpVectors( _edge.start, _edge.end, 0.5 );\r\n\t\t\t\t\t\t\taddConnectionEdge( _tri1, _tri2, _centerPoint );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.setEdges( edges );\r\n\r\n\t\tfunction addConnectionEdge( tri1, tri2, centerPoint ) {\r\n\r\n\t\t\ttri1.getMidpoint( _center );\r\n\t\t\ttri2.getMidpoint( _center2 );\r\n\r\n\t\t\ttri1.getPlane( _plane );\r\n\t\t\ttri2.getPlane( _plane2 );\r\n\r\n\t\t\tconst edge = new Line3();\r\n\t\t\tedge.start.copy( _center );\r\n\r\n\t\t\tif ( straightEdges ) {\r\n\r\n\t\t\t\t// get the projected centers\r\n\t\t\t\t_plane.projectPoint( _center2, _projected );\r\n\t\t\t\t_plane2.projectPoint( _center, _projected2 );\r\n\r\n\t\t\t\t// get the directions so we can flip them if needed\r\n\t\t\t\t_projectedDir.subVectors( _projected, _center );\r\n\t\t\t\t_projectedDir2.subVectors( _projected2, _center2 );\r\n\r\n\t\t\t\t// get the directions so we can flip them if needed\r\n\t\t\t\t_edgeDir.subVectors( centerPoint, _center );\r\n\t\t\t\t_edgeDir2.subVectors( centerPoint, _center2 );\r\n\r\n\t\t\t\tif ( _projectedDir.dot( _edgeDir ) < 0 ) {\r\n\r\n\t\t\t\t\t_projectedDir.multiplyScalar( - 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _projectedDir2.dot( _edgeDir2 ) < 0 ) {\r\n\r\n\t\t\t\t\t_projectedDir2.multiplyScalar( - 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// find the new points after inversion\r\n\t\t\t\t_vec.addVectors( _center, _projectedDir );\r\n\t\t\t\t_vec2.addVectors( _center2, _projectedDir2 );\r\n\r\n\t\t\t\t// project the points onto the triangle edge. This would be better\r\n\t\t\t\t// if we clipped instead of chose the closest point\r\n\t\t\t\ttri1.closestPointToPoint( _vec, _finalPoint );\r\n\t\t\t\ttri2.closestPointToPoint( _vec2, _finalPoint2 );\r\n\r\n\t\t\t\tedge.end.lerpVectors( _finalPoint, _finalPoint2, 0.5 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tedge.end.copy( centerPoint );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tedges.push( edge );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n", "import { Vector3 } from 'three';\r\nimport { Triangle } from 'three';\r\nimport { getTriCount } from '../core/utils/geometryUtils.js';\r\n\r\n// https://stackoverflow.com/questions/1406029/how-to-calculate-the-volume-of-a-3d-mesh-object-the-surface-of-which-is-made-up\r\nconst _tri = new Triangle();\r\nconst _normal = new Vector3();\r\nconst _relPoint = new Vector3();\r\nexport function computeMeshVolume( mesh ) {\r\n\r\n\t// grab the matrix and the geometry\r\n\tlet geometry;\r\n\tlet matrix;\r\n\tif ( mesh.isBufferGeometry ) {\r\n\r\n\t\tgeometry = mesh;\r\n\t\tmatrix = null;\r\n\r\n\t} else {\r\n\r\n\t\tgeometry = mesh.geometry;\r\n\t\tmatrix = Math.abs( mesh.matrixWorld.determinant() - 1.0 ) < 1e-15 ? null : mesh.matrixWorld;\r\n\r\n\t}\r\n\r\n\t// determine the number of relevant draw range elements to use\r\n\tconst index = geometry.index;\r\n\tconst pos = geometry.attributes.position;\r\n\tconst drawRange = geometry.drawRange;\r\n\tconst triCount = Math.min( getTriCount( geometry ), drawRange.count / 3 );\r\n\r\n\t// get a point relative to the position of the geometry to avoid floating point error\r\n\t_tri.setFromAttributeAndIndices( pos, 0, 1, 2 );\r\n\tapplyMatrix4ToTri( _tri, matrix );\r\n\t_tri.getNormal( _normal );\r\n\t_tri.getMidpoint( _relPoint ).add( _normal );\r\n\r\n\t// iterate over all triangles\r\n\tlet volume = 0;\r\n\tconst startIndex = drawRange.start / 3;\r\n\tfor ( let i = startIndex, l = startIndex + triCount; i < l; i ++ ) {\r\n\r\n\t\tlet i0 = 3 * i + 0;\r\n\t\tlet i1 = 3 * i + 1;\r\n\t\tlet i2 = 3 * i + 2;\r\n\t\tif ( index ) {\r\n\r\n\t\t\ti0 = index.getX( i0 );\r\n\t\t\ti1 = index.getX( i1 );\r\n\t\t\ti2 = index.getX( i2 );\r\n\r\n\t\t}\r\n\r\n\t\t// get the triangle\r\n\t\t_tri.setFromAttributeAndIndices( pos, i0, i1, i2 );\r\n\t\tapplyMatrix4ToTri( _tri, matrix );\r\n\t\tsubVectorFromTri( _tri, _relPoint );\r\n\r\n\t\t// add the signed volume\r\n\t\tvolume += signedVolumeOfTriangle( _tri.a, _tri.b, _tri.c );\r\n\r\n\t}\r\n\r\n\treturn Math.abs( volume );\r\n\r\n}\r\n\r\nfunction signedVolumeOfTriangle( p1, p2, p3 ) {\r\n\r\n\tconst v321 = p3.x * p2.y * p1.z;\r\n\tconst v231 = p2.x * p3.y * p1.z;\r\n\tconst v312 = p3.x * p1.y * p2.z;\r\n\tconst v132 = p1.x * p3.y * p2.z;\r\n\tconst v213 = p2.x * p1.y * p3.z;\r\n\tconst v123 = p1.x * p2.y * p3.z;\r\n\treturn ( 1 / 6 ) * ( - v321 + v231 + v312 - v132 - v213 + v123 );\r\n\r\n}\r\n\r\nfunction subVectorFromTri( tri, pos ) {\r\n\r\n\ttri.a.sub( pos );\r\n\ttri.b.sub( pos );\r\n\ttri.c.sub( pos );\r\n\r\n}\r\n\r\nfunction applyMatrix4ToTri( tri, mat = null ) {\r\n\r\n\tif ( mat !== null ) {\r\n\r\n\t\ttri.a.applyMatrix4( mat );\r\n\t\ttri.b.applyMatrix4( mat );\r\n\t\ttri.c.applyMatrix4( mat );\r\n\r\n\t}\r\n\r\n}\r\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCnC,IAAM;AAAA;AAAA,EAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACDzC,IAAM;AAAA;AAAA,EAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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",
  "names": ["leftBounds", "uint16Array", "uint32Array", "offset", "count", "areIntersecting", "closestPointLineToLine", "temp1", "temp2", "closestPointsSegmentToSegment", "sphereIntersectTriangle", "triangle", "triangle", "closestPointToPoint", "float32Array", "uint16Array", "uint32Array", "nodeIndex32", "nodeIndex16", "temp", "ray", "ray", "triangle", "uint32Array", "uint16Array", "float32Array", "_traverse", "byteOffset", "ray", "ray", "triangle", "ray", "float32Array", "uint16Array", "uint32Array", "ray", "float32Array", "uint16Array", "uint32Array", "float32Array", "uint16Array", "uint32Array", "obb", "obb2", "temp1", "triangle", "triangle2", "uint32Array", "uint16Array", "float32Array", "_traverse", "byteOffset", "ray", "_raycast", "float32Array", "uint16Array", "uint32Array", "_xyzFields", "ray", "_raycastFirst", "float32Array", "uint16Array", "uint32Array", "boundingBox", "triangle", "triangle2", "invertedMat", "obb", "obb2", "_intersectsGeometry", "float32Array", "uint16Array", "uint32Array", "tempMatrix", "obb", "obb2", "temp1", "temp2", "temp3", "temp4", "triangle", "triangle2", "obb", "uint32Array", "uint16Array", "_traverse", "ray", "triangle", "triangle2", "box", "boundingBox", "_box1", "_box2", "getIndexArray", "ensureIndex", "getVertexCount", "getTriCount", "ray", "ray", "ray", "getTriCount", "ensureIndex", "getTriCount", "EPSILON", "_vec", "triangle", "_ray", "_matrix", "_vec3", "_edge", "_matrix", "_tri", "l", "getTriCount", "i3", "i0", "i1", "i2", "type", "a", "b", "_matrix", "_tri2", "_vec", "_vec2", "_plane", "_plane2", "_ray", "_edge", "getTriCount", "ray", "_tri", "_normal", "getTriCount"]
}
